"""
author = 'Martin Lichtman'
created = 2013-04-02
modified >= 2014-04-21

cs_GUI.enaml

A GUI for the Cs experiment controller, written using the enaml toolkit for python.
"""

from __future__ import division
__author__ = 'Martin Lichtman'
import logging
logger = logging.getLogger(__name__)

from cs_errors import PauseError

from enaml.layout.api import vbox, hbox, align, horizontal, vertical, spacer, grid
from enaml.widgets.api import (MainWindow, MenuBar, Menu, Action,
                                Notebook, Page, Container, GroupBox, DualSlider, Slider,
                                Form, Label, CheckBox, SpinBox, PushButton, MPLCanvas,
                                MultilineField, ProgressBar, ScrollArea, Separator,
                                FileDialog,Window, StatusBar, StatusItem,
                                Stack, StackItem, ComboBox, HGroup, VGroup
)
from enaml.icon import Icon, IconImage
from enaml.image import Image
from enaml.core.declarative import d_
from enaml.core.include import Include
from enaml.stdlib.fields import FloatField, IntField
from enaml.core.api import Looper, Conditional
from enaml.styling import StyleSheet, Style, Setter
from enaml.validator import Validator
from atom.api import Member, Bool, Typed, observe, Callable
import threading, datetime, time, os, itertools
import numpy, itertools

from experiments import IndependentVariable
from instrument_property import ListProp

# redefine Field so that all Fields will have status_tips
from enaml.widgets.api import Field as OldField
enamldef Field(OldField):
    status_tip << text

enamldef MyStyleSheet(StyleSheet):
    Style:
        style_class = 'invalid'
        Setter:
            field = 'background-color'
            value = 'pink'
        Setter:
            field = 'border-color'
            value = 'red'
        Setter:
            field = 'border-style'
            value = 'solid'
        Setter:
            field = 'border-width'
            value = '2'
    Style:
        style_class = 'valid'

enamldef RefreshableLooper(Looper): self:
    """A Looper that sends a reference of itself to the backend controller, so it can be forcibly updated using the
    refresh_items() method."""
    initialized::
        iterable.gui = self

class MyBoolValidator(Validator):
    experiment=Member()

    def __init__(self,experiment):
        super(MyBoolValidator,self).__init__()
        self.experiment=experiment

    def validate(self,text):
        try:
            value = self.experiment.eval_bool(text)
        except:
            return False
        return True


class MyEnumValidator(Validator):
    experiment=Member()
    allowedValues=Member()

    def __init__(self,experiment,allowedValues):
        super(MyEnumValidator,self).__init__()
        self.experiment=experiment
        self.allowedValues=allowedValues

    def validate(self,text):
        try:
            value = self.experiment.eval_general(text)
        #check for parsing errors
        except:
            return False
        #check if the value is one of the ones allowed by this particular Enum
        if value not in self.allowedValues:
            return False
        #if we've gotten this far, all tests have passed
        return True

#TODO: make these Fields have validation and able to process statements
enamldef MyIntField(Field):
    """This class exists to make an IntField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = int(text)

enamldef MyFloatField(Field):
    """This class exists to make a FloatField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = float(text)

enamldef MyBoolField(Field):
    """This class exists to make a BoolField (which isn't something that is available anyway),
     that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = bool(text)

enamldef IndexedStack(GroupBox): indexedStack:
    attr iterable=Typed(ListProp)
    attr viewType #=Class(StackItem)  #do we really have to declare what type? I suppose this was so that we would be okay with creating an instance
    hug_height = 'strong'
    hug_width = 'strong'

    Container: controls:
        constraints=[hbox(addButton,removeButton,combo)]
        PushButton: addButton:
            text='+'
            constraints=[width==50,height==20]
            clicked::
                iterable.add()
                combo.maximum=len(iterable)-1
                combo.value=combo.maximum
        PushButton: removeButton:
            text='-'
            constraints=[width==50,height==20]
            clicked::
                i=combo.value
                if i>=0:
                    iterable.pop(i)
                    combo.maximum=len(iterable)-1
                    if i>1:
                        combo.value=i-1
                    else:
                        combo.value=0
        # RefreshableComboBox: combo:
            # items<<[str(i)+' '+n.description for i,n in enumerate(iterable)]
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
    Stack: stack:
        index<<combo.value
        RefreshableLooper:
            iterable<<indexedStack.iterable
            Include:
                objects=[viewType(item=loop_item)]

enamldef IndexedContainer(GroupBox):
    # This is like an IndexedStack, but instead of using a stack, we just have only one object to display and we
    # change what that one object is using an Include
    # The attribute 'iterable' must be a ListProp.  This container then provides controls to add and remove elements.
    # The GUI element viewType must define 'item' which is the element of the ListProp that will be passed to it
    # The attribute dynamic enables the buttons to dynamically add or remove list items

    attr iterable = Typed(ListProp)
    # Below is commented out because we don't actually have to declare the type.
    # This was so that we would be okay with creating an instance, but it's not necessary
    attr viewType  # = Class(StackItem)
    # The attribute static disables the buttons to dynamically add or remove list items
    attr dynamic = True

    hug_height = 'strong'
    hug_width = 'strong'

    HGroup:
        #constraints=[hbox(addButton,removeButton,combo)]
        Conditional:
            condition = dynamic
            PushButton: addButton:
                text='+'
                constraints=[width==50,height==20]
                clicked::
                    iterable.add()
                    combo.maximum=len(iterable)-1
                    combo.value=combo.maximum
            PushButton: removeButton:
                text='-'
                constraints=[width==50,height==20]
                clicked::
                    i=combo.value
                    if i>=0:
                        iterable.pop(i)
                        combo.maximum=len(iterable)-1
                        if i>1:
                            combo.value=i-1
                        else:
                            combo.value=0
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
    # the actual thing to display
    Conditional:
        condition << ((iterable.length>0) and (combo.value >=0))
        Include:
           objects << [viewType(item=iterable[combo.value])]

def get_load_file_callback(experiment):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.load(dlg.path)
            except PauseError:
                pass
    return load_file_callback

def get_save_file_callback(experiment):
    def save_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.save(dlg.path)
            except PauseError:
                pass
    return save_file_callback

enamldef CsMenuBar(MenuBar): menuBar:
    attr experiment
    attr mainWindow
    
    Menu:
        title = '&File'
        Action:
            text = 'Load\tCtrl+L'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Choose file to load',
                    mode='open_file',
                    path=experiment.settings_path,
                    callback=get_load_file_callback(experiment),
                    ).open()
        Action:
            text = 'Save\tCtrl+S'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Save As?',
                    mode='save_file',
                    path=os.path.join(experiment.settings_path,'settings-{}.hdf5'.format(datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S'))),
                    callback=get_save_file_callback(experiment),
                    ).open()
        Action:
            text = 'Quit\tCtrl+Q'
            triggered::
                mainWindow.close()
    Menu:
        title = '&Experiment'
        Action:
            text = 'Reset and Run\tCtrl+R'
            triggered::experiment.resetAndGoThread()
        Action:
            text = 'Reset'
            triggered::experiment.resetThread()
        Action:
            text = 'Run/Continue\tCtrl+G'
            triggered::experiment.goThread()
        Menu:
            title = 'Pause...'
            Action:
                checkable = True
                text = 'After Measurement\tCtrl+M'
                checked := experiment.pauseAfterMeasurement
            Action:
                checkable = True
                text = 'After Iteration'
                checked := experiment.pauseAfterIteration
            Action:
                checkable = True
                text = 'After Error'
                checked := experiment.pauseAfterError
            Action:
                text = 'Now\tCtrl+P'
                triggered :: experiment.pause_now()
        Action:
            text = 'End and Upload'
            triggered::experiment.endThread()
        Action:
            text = 'Upload'
            triggered::experiment.uploadNowThread()
        Action:
            text = 'Stop\tCtrl+H'
            triggered::experiment.stop()
    Menu:
        title = 'Evaluation'
        Action:
            text='Update variables throughout experiment'
            triggered :: experiment.evaluateAll()

enamldef EvalProp(GroupBox):
    attr prop

    padding = 0
    flat = True
    title << prop.name
    constraints = [desc.width==func.width, func.width==val.width, hbox(desc,func,val), align('v_center',desc,func,val)]

    # can be made to show an error status by setting valid to false
    attr valid = True

    Field: desc:
        text := prop.description
        placeholder = 'description'

    Field: func:
        text := prop.function
        placeholder = prop.placeholder
        style_class << 'valid' if prop.valid else 'invalid'

    Label: val:
        text << prop.valueStr

enamldef MultilineProp(GroupBox):        
    attr prop
    flat=True
    title:=prop.name
    constraints=[vbox(desc,hbox(func,val)),align('top',func,val)]
    Field: desc:
        text:=prop.description
        placeholder='description'
    MultilineField: func:
        text:=prop.function
    Label: val:
        text << prop.valueStr

enamldef LabelBox(HGroup):
    alias checked: box.checked
    alias text: label.text
    
    padding=0
    hug_height='strong'
    hug_width='strong'
    align_widths = False

    Label: label:
        pass
    CheckBox: box:
        pass

enamldef CheckField(HGroup):
    alias checked: box.checked
    alias text: field.text
    alias placeholder: field.placeholder

    padding = 0
    hug_height='strong'
    hug_width='strong'
    align_widths = False

    CheckBox: box:
        pass
    Field: field:
        pass

enamldef LabelField(VGroup):
    alias label: l1.text
    alias text: f1.text
    alias placeholder: f1.placeholder

    padding = 0
    hug_height='strong'
    hug_width='strong'

    Label: l1:
        pass
    Field: f1:
        pass

#class RefreshableComboBox(ComboBox):
#    refresh = EnamlEvent

enamldef ExperimentPage(Window):
    attr experiment
    title = 'Experiment'

    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'

            Form: form:
                constraints = [(midline==left)|'strong'] #,(width==parent.contents_width)|'strong']
                Label:
                    text="Status:"
                Label:
                    text<<experiment.statusStr

                Label:
                    text='Pause after iteration'
                CheckBox:
                    checked:=experiment.pauseAfterIteration

                Label:
                    text='Pause after measurement'
                CheckBox:
                    checked:=experiment.pauseAfterMeasurement

                Label:
                    text='Pause after error'
                CheckBox:
                    checked:=experiment.pauseAfterError

                Label:
                    text='Reload settings after pause?'
                CheckBox:
                    checked:=experiment.reload_settings_after_pause

                Label:
                    text = 'enable sounds'
                CheckBox:
                    checked := experiment.enable_sounds

                Label:
                    text = 'start each instrument in a separate thread'
                CheckBox:
                    checked := experiment.enable_instrument_threads

                Label: text='Save Data?'
                CheckField:
                    checked:=experiment.saveData
                    text:=experiment.localDataPath
                    placeholder='local data path'

                Label: text='Save Settings?'
                CheckBox:
                    checked:=experiment.saveSettings

                Label: text='Save separate notes.txt?'
                CheckBox:
                    checked:=experiment.save_separate_notes

                Label: text='Save 2013 style files?'
                CheckBox:
                    checked:=experiment.save2013styleFiles

                Label: text='Copy Data to Network?'
                CheckField:
                    checked:=experiment.copyDataToNetwork
                    text:=experiment.networkDataPath
                    placeholder='network data path'

                Label: text='Experiment description suffix for filename'
                Field: text:=experiment.experimentDescriptionFilenameSuffix

                Label: text='Measurement Timeout [s]'
                FloatField: value:=experiment.measurementTimeout

                Label: text='Measurements per Iteration'
                IntField: value:=experiment.measurementsPerIteration

                Label: text='E-mail on error/completion?'
                CheckField:
                    checked:=experiment.willSendEmail
                    text:=experiment.emailAddresses

                Label: text='Progress'
                Label: text<<'{}%'.format(experiment.progressGUI)

                Label: text='Iteration'
                Label: text<<experiment.iterationStr

                Label: text='Measurement'
                Label: text<<experiment.measurementStr

                Label: text='Good Measurements'
                Label: text<<experiment.goodMeasurementsStr

                Label: text='Time started'
                Label: text<<experiment.timeStartedStr

                Label: text='Time after last measurement'
                Label: text<<experiment.currentTimeStr

                Label: text='Time elapsed'
                Label: text<<experiment.timeElapsedStr

                Label: text='Estimated total time'
                Label: text<<experiment.totalTimeStr

                Label: text='Estimated time remaining'
                Label: text<<experiment.timeRemainingStr

                Label: text='Estimated completion time'
                Label: text<<experiment.completionTimeStr

                Label: text='Notes'
                MultilineField:
                    text:=experiment.notes

enamldef VariableEntry(GroupBox):
    attr indepVar
    attr list_index

    #hug_height = 'strong'
    #hug_width = 'strong'
    #constraints = [vbox(variable,optimizer1,optimizer2,values,status), align('left',variable,optimizer1,optimizer2,values,status)]

    HGroup: variable:
        align_widths = False
        constraints = [nameCont.width==100, descCont.width==200, funcCont.width==200]
        Label:
            text << list_index
        Field: nameCont:
            text := indepVar.name
            placeholder = 'name'
        Field: descCont:
            text := indepVar.description
            placeholder = 'description'
        Field: funcCont:
            text := indepVar.function
            placeholder = 'function'
        Form:
            Label:
                text = 'optimize?'
            CheckBox:
                checked := indepVar.optimize
        Form:
            Label:
                text = 'initial step (abs)'
            FloatField:
                value := indepVar.optimizer_initial_step
        Form:
            Label:
                text = 'end tolerance (abs)'
            FloatField:
                value := indepVar.optimizer_end_tolerance
        Form:
            Label:
                text = 'min'
            FloatField:
                value := indepVar.optimizer_min
        Form:
            Label:
                text = 'max'
            FloatField:
                value := indepVar.optimizer_max
    HGroup:
        align_widths = False
        Label: values:
            text << 'values: '+indepVar.valueListStr
        Label:
            text << 'step: '+str(indepVar.index)+' of '+str(indepVar.steps)
        Label:
            text = 'current value'
        Field:
            text << indepVar.currentValueStr
            read_only = True

enamldef IndependentVariables(Window):
    attr independentVariables

    title = 'Independent Variables'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:

                Label:
                    text = 'Evaluated after Constants and before Dependents.  Inner loop on top.'

                GroupBox:
                    HGroup:
                        SpinBox: spin0:
                            minimum=0
                            maximum << independentVariables.length
                        PushButton: addButton0:
                            text='+'
                            clicked::
                                independentVariables.add_at(spin0.value)
                        PushButton: removeButton0:
                            text='-'
                            clicked::
                                independentVariables.pop(spin0.value)

                RefreshableLooper:
                    iterable<<independentVariables
                    VariableEntry:
                        indepVar << loop_item
                        list_index << str(loop_index)

enamldef Variables(Window):
    attr experiment

    title = 'Constants and Dependent Variables'

    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container: page:
                style_class << 'valid' if experiment.valid else 'invalid'

                GroupBox: variablesNotToSave:
                    hug_height='strong'
                    title='Variables Not To Save to HDF5 (comma separated)'
                    Field:
                        text:=experiment.variablesNotToSave
                        placeholder='scipy,numpy,x'

                HGroup:
                    constraints = [align('top', constants, dependents), constants.width==dependents.width]

                    GroupBox: constants:
                        title='Constants (Evaluated 1st, before Independents)'

                        Label:
                            text='Define constants using python code below.'
                        MultilineField:
                            constraints = [bottom==page.contents_bottom]
                            text:=experiment.constantsStr

                    GroupBox: dependents:
                        title='Dependent Variables (Evaluated 3rd, after Independents)'

                        Label:
                            text='Define dependent variables using python code below.'
                        MultilineField:
                            constraints = [bottom==page.contents_bottom]
                            text:=experiment.dependentVariablesStr

enamldef Reports(Window):
    attr experiment

    title = 'Reports'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    GroupBox:
                        title = 'Constant Report'
                        hug_height = 'strong'
                        hug_width = 'strong'
                        constraints = [hbox(f1,lb1),align('top',f1,lb1)]
                        MultilineField: f1:
                            constraints = [height==950, width==600]
                            text := experiment.constantReport.function
                            style_class << 'valid' if experiment.constantReport.valid else 'invalid'
                        Label: lb1:
                            text << experiment.constantReport.valueStr
                    GroupBox:
                        title = 'Variable Report'
                        hug_height = 'strong'
                        hug_width = 'strong'
                        constraints = [hbox(f2,lb2),align('top',f2,lb2)]
                        MultilineField: f2:
                            constraints = [height==950, width==600]
                            text := experiment.variableReport.function
                            style_class << 'valid' if experiment.variableReport.valid else 'invalid'
                        Label: lb2:
                            text << experiment.variableReport.valueStr

enamldef LabViewPage(Window):
    attr LabView

    title = 'PXI communication'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='strong'
                Container:
                    constraints=[hbox(b1,b3,b4),b1.width==100,b3.width==100,b4.width==100]
                    PushButton: b1:
                        text='open connection'
                        clicked::
                            LabView.openThread()
                    PushButton: b3:
                        text='update settings'
                        clicked::
                            LabView.update()
                    PushButton: b4:
                        text='close connection'
                        clicked::
                            LabView.close()

                Form:
                    Label:
                        text='enable communication with LabView system?'
                    CheckBox:
                        checked:=LabView.enable
                    Label:
                        text='IP address of LabView system'
                    Field:
                        text:=LabView.IP
                    Label:
                        text='communications port'
                    IntField:
                        value:=LabView.port
                    Label:
                        text='cycle experiment continuously even when not taking data?'
                    CheckBox:
                        checked:=LabView.cycleContinuously
                EvalProp:
                    prop<<LabView.timeout
                Form:
                    Label:
                        text='connected'
                    CheckBox:
                        checked:=LabView.connected
                        enabled=False
                    Label: text='LabView error'
                    Label: text<<str(LabView.error)

                GroupBox:
                    title='TCP output message'
                    constraints = [vbox(scroller1),(height==500)|'strong']
                    hug_width='ignore'
                    ScrollArea:scroller1:
                        Container:
                            hug_height='ignore'
                            hug_width='ignore'
                            Label:
                                hug_height='ignore'
                                hug_width='ignore'
                                text<<LabView.msg

                GroupBox:
                    title='LabView log'
                    constraints = [vbox(scroller2),(height==500)|'strong']
                    hug_width='ignore'
                    ScrollArea: scroller2:
                        Container:
                            hug_height='ignore'
                            hug_width='ignore'
                            Label:
                                hug_height='ignore'
                                hug_width='ignore'
                                text<<LabView.log

enamldef DOchannel(Container):
    attr channel
    attr index
    hug_height='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel.description
        placeholder='description'
    Field: activeF:
        text:=channel.active.function
        placeholder='active?'
    Label: activeL:
        text<<str(channel.active.value)

enamldef HSDIOScriptTrigger(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
        EvalProp:
            prop<<item.id
        EvalProp:
            prop<<item.source
        EvalProp:
            prop<<item.type
        EvalProp:
            prop<<item.edge
        EvalProp:
            prop<<item.level

enamldef StartTrigger(GroupBox):
    attr trigger
    title='Start Trigger'
    
    EvalProp:
        prop<<trigger.waitForStartTrigger
    EvalProp:
        prop<<trigger.source
    EvalProp:
        prop<<trigger.edge

class RefreshableMPLCanvas(MPLCanvas):
    """ An MPLCanvas that can be refreshed on command by toggling refresh.
    Requires adding a function to MPLCanvas in
    C:\Users\Saffmanlab\AppData\Local\Enthought\Canopy\User\Lib\site-packages\enaml\qt\qt_mpl_canvas.py:
        def on_action_set_refresh(self, content):
            self.refresh_mpl_widget()
    """
    
    #: Toggle this to refresh the canvas
    refresh = d_(Bool())

class RemoveEventContainer(Container):
    remove=d_(Bool())

enamldef NumpyAOchannel(Container):
    attr channel
    attr index

    hug_height='strong'
    hug_width='strong'
    padding=0
    Form:
        Label: text=str(index)
        Field:
            text:=channel['description']
            placeholder='description'

enamldef NumpyAOchannels(GroupBox):
    attr channels
    title='channels (#, description)'
    hug_height='strong'
    hug_width='strong'
    Container: controls:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton,removeButton)]
        SpinBox: spin0:
            minimum=0
            maximum<<len(channels.array)
        PushButton: addButton:
            text='+'
            clicked::
                channels.add(spin0.value)
        PushButton: removeButton:
            text='-'
            clicked::
                channels.remove(spin0.value)
    Container:
        Include:
            objects<<[NumpyAOchannel(channel=x,index=i) for i,x in enumerate(channels.array)]


enamldef NumpyDOchannel(Container):
    attr channel
    attr index
    attr digitalout #the DAQmxDO or HSDIO
    attr experiment

    hug_height='strong'
    hug_width='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel['description']
        placeholder='description'
    Field: activeF:
        text:=channel['function']
        placeholder='active?'
        validator<<MyBoolValidator(experiment)
        text::
            channel['value']=experiment.eval_bool(text)
            activeL.text=str(channel['value']) #must be updated manually because the channel['value'] identity does not change
            digitalout.evaluate()
    Label: activeL:
        text<<str(channel['value'])

enamldef NumpyDOchannels(GroupBox):
    attr channels
    title='channels (#, description, active?)'
    hug_height='strong'
    hug_width='strong'
    #constraints=[controls.left==dynoCont.left]
    Container: controls:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton,removeButton)]
        SpinBox: spin0:
            minimum=0
            maximum<<len(channels.array)
        PushButton: addButton:
            text='+'
            clicked::
                channels.add(spin0.value)
        PushButton: removeButton:
            text='-'
            clicked::
                channels.remove(spin0.value)
    Container: dynoCont:
        Include: dyno:
            objects<<[NumpyDOchannel(channel=x,index=i,digitalout=channels.digitalout,experiment=channels.experiment) for i,x in enumerate(channels.array)]

enamldef NumpyState(Form):
    attr state
    attr experiment
    attr waveform
    attr value_str
    attr valid

    padding=0

    Field:
        constraints = [width == 100,height==20]
        style_class << 'valid' if valid else 'invalid'
        text:=state['function']
        text::
            value, parent.valid = experiment.eval_general(text)
            if value is None:
                state['value'] = 5
                parent.value_str = ''
            elif (value == 0) or (value ==1):
                state['value'] = value
                parent.value_str = str(state['value']) #must be updated manually because state['value'] identity does not change
            else:
                logger.warning('Invalid state in waveform {}.  States must evaluate to None, 0 or 1.\n{} = {}'.format(waveform.name,text,value))
                state['value'] = 5
                parent.value_str = ''
                parent.valid = False
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width==50, height==20]
        text << value_str

enamldef ChannelCombo(ComboBox):
    attr wfm
    attr channels
    attr channelList
    attr position
    
    items<<[str(i)+' '+x for i,x in enumerate(channels.array['description'])]
    index<<int(channelList[position])
    index::
        channelList[position]=numpy.uint8(index)
        wfm.updateFigure()

enamldef TransitionsLabel(Container):
    padding=0
    Label:
        constraints = [height == 20]
        text='description'
    Label:
        constraints = [height == 20]
        text='time'

enamldef DescriptionLabel(Label):
    constraints = [height == 20]
    text='description'
    
enamldef TimeLabel(Label):
    constraints = [height == 20]
    text='time'

enamldef TransitionDescription(Field):
    attr transition
    constraints = [height==20]
    placeholder = 'description'
    text:=transition['description']

enamldef TransitionTime(Form):
    attr experiment
    attr waveform
    attr transition
    attr value_str
    attr valid
    
    padding=0
    
    Field:
        constraints = [width == 100, height==20]
        placeholder = 'time'
        text := transition['function']
        style_class << 'valid' if valid else 'invalid'
        text::
            transition['value'], parent.valid = experiment.eval_float(text)
            value_str = '{:.6f}'.format(transition['value']) #must be updated manually because transition['value'] identity does not change
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width==50, height==20]
        text << value_str

enamldef NumpyWaveform(Container):
    attr waveform
    
    hug_height='strong'
    hug_width='ignore'
    constraints=[vbox(plotcontrols,details),align('left',plotcontrols,details)]
    
    Container: plotcontrols:
        hug_width='strong'
        hug_height='strong'
        constraints=[hbox(lmin,plotmin,lmax,plotmax)]
        padding=0
        Label: lmin:
            text='plot min'
        Field: plotmin:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmin=-1
                else:
                    waveform.plotmin=float(text)
                waveform.updateFigure()
        Label: lmax:
            text='plot max'
        Field: plotmax:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmax=-1
                else:
                    waveform.plotmax=float(text)
                waveform.updateFigure()
    
    Container: details:
        constraints=[vbox(hbox(nameField,timeControls,channelControls),transitions)]
        hug_height='strong'
        hug_width='strong'

        Field: nameField:
            constraints = [width == 150, height == 20]
            text:=waveform.name

        GroupBox: timeControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l0,spin0,addButton0,removeButton0)]
            Label: l0:
                text='times'
            SpinBox: spin0:
                minimum=0
                maximum<<len(waveform.transitions.array)
            PushButton: addButton0:
                text='+'
                clicked::
                    waveform.addTransition(spin0.value)
            PushButton: removeButton0:
                text='-'
                clicked::
                    waveform.removeTransition(spin0.value)

        GroupBox: channelControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l1,spin1,addButton1,removeButton1)]
            Label: l1:
                text='channels'
            SpinBox: spin1:
                minimum=0
                maximum<<len(waveform.channelList)
            PushButton: addButton1:
                text='+'
                clicked::
                    waveform.addChannel(spin1.value)
            PushButton: removeButton1:
                text='-'
                clicked::
                    waveform.removeChannel(spin1.value)
        GroupBox: transitions:
            hug_height='strong'
            hug_width='strong'
            title='waveform transition and sequence (valid states: blank(continue), 0(off), 1(on))'
            constraints<<[grid(*[statesDyno.objects[i:(i+len(waveform.transitions.array)+1)] for i in range(0, len(statesDyno.objects), len(waveform.transitions.array)+1)])] if len(statesDyno.objects)>0 else []
            Include: statesDyno:
                objects << ([DescriptionLabel()]
                    +[TransitionDescription(transition=t) for t in waveform.transitions.array]
                    +[TimeLabel()]
                    +[TransitionTime(transition=t,experiment=waveform.experiment,waveform=waveform,value_str=value_str,valid=valid) for t,value_str,valid in zip(waveform.transitions.array,waveform.transitions.value_str,waveform.transitions.valid)]
                    +(list(itertools.chain(*map(list,zip(*([[ChannelCombo(wfm=waveform,channels=waveform.digitalout.channels,channelList=waveform.channelList,position=i) for i in xrange(len(waveform.channelList))]]
                    +[[NumpyState(state=s,experiment=waveform.experiment,waveform=waveform,value_str=value_str,valid=valid) for s,value_str,valid in zip(waveform.sequence.array.flat,waveform.sequence.value_str.flat,waveform.sequence.valid.flat)][i:i+len(waveform.channelList)] for i in range(0,waveform.sequence.array.size,len(waveform.channelList))]))))) if (len(waveform.channelList)>0) else [])
                    )

def get_load_waveform_callback(HSDIO):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                HSDIO.import_waveform(dlg.path)
            except PauseError:
                pass
    return load_file_callback

enamldef FunctionalWaveforms(Window):
    attr waveforms

    title = 'Functional Waveform Definitions'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'
                constraints = [enable.left==contents_left, enable.bottom+5==field.top, enable.top==contents_top, field.left==contents_left, field.right==contents_right, field.bottom==contents_bottom]

                LabelBox: enable:
                    text = 'enable'
                    checked := waveforms.enable

                MultilineField: field:
                    # waveform entry
                    hug_width = 'ignore'
                    hug_height = 'ignore'
                    text := waveforms.text

enamldef FunctionalWaveformsGraph(Window):
    attr graph

    title = 'Functional Waveforms Graph'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                constraints = [canvas.top==contents_top, canvas.left==contents_left, canvas.right==contents_right, canvas.bottom+5==controls.top, controls.left==contents_left, controls.bottom==contents_bottom]

                MPLCanvas: canvas:
                    figure << graph.figure

                # plot controls
                HGroup: controls:
                    align_widths = False
                    hug_width='strong'
                    hug_height='strong'
                    padding=0
                    LabelBox:
                        text = 'enable'
                        checked := graph.enable
                    Label: text = 'HSDIO'
                    Field:
                        placeholder = 'HSDIO channels to plot'
                        text := graph.HSDIO_channels_to_plot
                    LabelBox:
                        text = 'HSDIO ticks'
                        checked := graph.draw_HSDIO_ticks
                    Label: text = 'AO'
                    Field:
                        placeholder = 'AO channels to plot'
                        text := graph.AO_channels_to_plot
                    LabelBox:
                        text = 'AO ticks'
                        checked := graph.draw_AO_ticks
                    Label: text = 'DAQmxDO'
                    Field:
                        placeholder = 'DAQmxDO channels to plot'
                        text := graph.DO_channels_to_plot
                    LabelBox:
                        text = 'DO ticks'
                        checked := graph.draw_DO_ticks
                    LabelBox:
                        text = 'labels'
                        checked := graph.draw_label_ticks
                    Label: text = 'plot min'
                    Field:
                        placeholder = 'blank for autolimit'
                        text := graph.plotmin_str
                    Label: text = 'plot max'
                    Field:
                        placeholder = 'blank for autolimit'
                        text := graph.plotmax_str
                    Label: text = 'units'
                    FloatField: value := graph.units
                    Label: text = 'AO scale'
                    FloatField: value := graph.AO_scale

enamldef HSDIO_DigitalOutPage(Window):
    attr HSDIO

    title = 'HSDIO'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label: text = 'enable'
                    CheckBox: checked := HSDIO.enable
                StartTrigger: trigger<<HSDIO.startTrigger
                IndexedStack:
                    title='Script Triggers'
                    iterable<<HSDIO.triggers
                    viewType=HSDIOScriptTrigger
                EvalProp: prop<<HSDIO.resourceName
                EvalProp: prop<<HSDIO.clockRate
                EvalProp: prop<<HSDIO.units
                EvalProp: prop<<HSDIO.hardwareAlignmentQuantum
                Form:
                    Label: text = 'number of channels (multiples of 32)'
                    IntField: value := HSDIO.numChannels
                NumpyDOchannels: p8:
                    channels<<HSDIO.channels

enamldef DAQmxDigitalOutPage(Window):
    attr DAQmx

    title = 'DAQmx Digital Output'
    style_class << 'valid' if experiment.valid else 'invalid'

    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                LabelBox:
                    text = 'enable'
                    checked := DAQmx.enable
                EvalProp: prop<<DAQmx.resourceName
                EvalProp: prop<<DAQmx.clockRate
                EvalProp: prop<<DAQmx.units
                StartTrigger: trigger<<DAQmx.startTrigger
                NumpyDOchannels: channels<<DAQmx.channels

enamldef DDS_profile(Container):
    attr profile
    
    hug_height='strong'
    hug_width='strong'
    padding=0

    Container:
        padding=0
        hug_height='strong'
        hug_width='strong'
        constraints=[vbox(description,hbox(container1,container2))]
        Form: description:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=profile.description
        Container: container1:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.frequency
            EvalProp:
                prop<<profile.amplitude
            EvalProp:
                prop<<profile.phase
            EvalProp:
                prop<<profile.RAMMode
            EvalProp:
                prop<<profile.ZeroCrossing
            EvalProp:
                prop<<profile.NoDwellHigh
            EvalProp:
                prop<<profile.FunctionOrStatic
        Container: container2:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.RAMFunction
            EvalProp:
                prop<<profile.RAMInitialValue
            EvalProp:
                prop<<profile.RAMStepValue
            EvalProp:
                prop<<profile.RAMTimeStep
            EvalProp:
                prop<<profile.RAMNumSteps
            IndexedStack:
                title='RAMStaticArray'
                iterable<<profile.RAMStaticArray
                viewType=RAMStaticPoint

enamldef RAMStaticPoint(StackItem):
    attr item
    Container:
        Form:
            Label:
                text = 'f/phi/A'
            FloatField:
                value := item.fPhiA
            Label:
                text = 'Mag'
            FloatField:
                value := item.Mag

enamldef ItemProp(StackItem):
    attr item
    
    Container:
        padding=0
        EvalProp:
            prop<<item

enamldef DDS_channel(GroupBox):
    attr channel
    attr index
    
    title='channel '+str(index)
    constraints=[hbox(vbox(parameters,RAM),profiles)]

    GroupBox: parameters:
        title='channel parameters'
        flat=True
        constraints=[vbox(description,power,refClockRate,fullScaleOutputPower)]
        Form: description:
            Label:
                text='description'
            Field:
                text:=channel.description
        EvalProp: power:
            prop<<channel.power
        EvalProp: refClockRate:
            prop<<channel.refClockRate
            enabled = False
        EvalProp: fullScaleOutputPower:
            prop<<channel.fullScaleOutputPower
    
    GroupBox: RAM:
        title='RAM defaults'
        flat=True
        EvalProp:
            prop<<channel.RAMenable
        EvalProp:
            prop<<channel.RAMDestType
        EvalProp:
            prop<<channel.RAMDefaultFrequency
        EvalProp:
            prop<<channel.RAMDefaultAmplitude
        EvalProp:
            prop<<channel.RAMDefaultPhase

    GroupBox: profiles:
        title='profiles'
        hug_height='strong'
        hug_width='strong'
        ComboBox: combo:
            items << list(channel.profileDescriptionList)
            index = (0 if (channel.profiles.length>0) else -1) # pick first profile on load
#        Stack: p1:
#            index<<combo.index
#            RefreshableLooper:
#                iterable<<channel.profiles
#                StackItem:
#                    DDS_profile:
#                        profile<<loop_item
        Conditional:
            condition << ((channel.profiles.length>0) and (combo.index >= 0))
            DDS_profile:
                profile << channel.profiles.listProperty[combo.index]

enamldef DDS_box(Form):
    attr box

    Label:
        text='enable'
    CheckBox:
        checked:=box.enable

    Label:
        text='Description'
    Field:
        text:=box.description

    PushButton:
        text='select USB device reference'
        clicked::
            box.deviceReference=combo.selected_item.strip()
    ComboBox: combo:
        items<<list(box.DDS.deviceList)

    Label:
        text='NI USB-8451 device reference'
    Field:
        pass
        text:=box.deviceReference

    Label:
        text='DIO port'
    IntField:
        #maximum = sys.maxint  # this crashes on Windows, but not on OS X
        maximum = 999999
        minimum = 0
        value:=box.DIOport
    Label:
        text='serialClockRate'
    IntField:
        value := box.serialClockRate

    GroupBox:
        hug_height='strong'
        hug_width='strong'
        title='channels'
        RefreshableLooper:
            iterable<<box.channels
            DDS_channel:
                index<<loop_index
                channel<<loop_item

enamldef DDS_Page(Window):
    attr DDS

    title = 'DDS'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    PushButton:
                        text = 'open connection'
                        clicked::
                            DDS.openThread()
                    PushButton:
                        text = 'close connection'
                        clicked::
                            DDS.close()
                    Label: text = 'IP address'
                    Field: text := DDS.IP
                    Label: text = 'TCP port'
                    IntField: value := DDS.port
                    EvalProp:
                        prop << DDS.timeout
                    Label: text = 'enable'
                    CheckBox: checked := DDS.enable
                    LabelBox:
                        text='initialized?'
                        checked<<DDS.isInitialized
                        enabled=False #keep it greyed out.
                    PushButton:
                        text='Get DDS Device List'
                        clicked :: DDS.getDDSDeviceListThread()
                    PushButton:
                        text='Initialize and Load'
                        clicked :: DDS.initializeDDSThread()
                    PushButton:
                        text='Load'
                        clicked :: DDS.loadDDSThread()

                GroupBox:
                    title = 'DDS boxes'
                    HGroup:
                        align_widths = False
                        ComboBox: combo:
                            items<<list(DDS.boxDescriptionList)
                            index = (0 if (DDS.boxes.length>0) else -1) # pick first profile on load
                        PushButton:
                            text='+'
                            constraints=[width==50,height==20]
                            clicked::
                                DDS.boxes.add()
                                DDS.updateBoxDescriptionList()
                                combo.index=len(DDS.boxes)-2 #point to new box
                        PushButton:
                            text='-'
                            constraints = [width==50,height==20]
                            clicked::
                                i = combo.index
                                if i >= 0:
                                    DDS.boxes.pop(i)
                                    DDS.updateBoxDescriptionList()
                                    combo.index = i-1
                    Container:
                        padding = 0
                        Conditional:
                            condition << ((DDS.boxes.length>0) and (combo.index >= 0))
                            DDS_box:
                                box << DDS.boxes.listProperty[combo.index]

                Form:
                    Label: text = 'connected'
                    CheckBox:
                        checked := DDS.connected
                        enabled = False
                    Label: text='DDS error'
                    Label: text<<str(DDS.error)
                    Label: text='DDS log'
                    Label: text<<DDS.log

enamldef RF_gen(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            Label:
                text='description'
            Field:
                text:=item.description
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power

enamldef HP83623A(StackItem):
    attr item
    
    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            
            Label:
                text='description'
            Field:
                text:=item.description
            
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power
        EvalProp:
            prop<<item.RFoutput
        EvalProp:
            prop<<item.externalTrigger

enamldef RFGenPage(Window):
    attr LabView

    title = 'RF Generators'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked :=  LabView.RF_generators.enable
                IndexedStack: i1:
                    title='HP83623A'
                    iterable=LabView.RF_generators.HP83623A_list
                    viewType=HP83623A
                IndexedStack: i2:
                    title='HP8662A'
                    iterable=LabView.RF_generators.HP8662A_list
                    viewType=RF_gen
                IndexedStack: i3:
                    title='HP83712B'
                    iterable=LabView.RF_generators.HP83712B_list
                    viewType=RF_gen

enamldef CameraPage(Window):
    attr camera

    title = 'Hamamatsu Camera'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='strong'
                hug_width='strong'
                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := camera.enable
                EvalProp:
                    prop<<camera.saveAsPNG
                EvalProp:
                    prop<<camera.saveAsASCII
                EvalProp:
                    prop<<camera.forceImagesToU16
                EvalProp:
                    prop<<camera.EMGain
                EvalProp:
                    prop<<camera.analogGain
                EvalProp:
                    prop<<camera.exposureTime
                EvalProp:
                    prop<<camera.scanSpeed
                EvalProp:
                    prop<<camera.lowLightSensitivity
                EvalProp:
                    prop<<camera.externalTriggerMode
                EvalProp:
                    prop<<camera.triggerPolarity
                EvalProp:
                    prop<<camera.externalTriggerSource
                EvalProp:
                    prop<<camera.cooling
                EvalProp:
                    prop<<camera.fan
                EvalProp:
                    prop<<camera.scanMode
                EvalProp:
                    prop<<camera.photoelectronScaling
                EvalProp:
                    prop<<camera.subArrayLeft
                EvalProp:
                    prop<<camera.subArrayTop
                EvalProp:
                    prop<<camera.subArrayWidth
                EvalProp:
                    prop<<camera.subArrayHeight
                EvalProp:
                    prop<<camera.superPixelBinning
                EvalProp:
                    prop<<camera.frameGrabberAcquisitionRegionLeft
                EvalProp:
                    prop<<camera.frameGrabberAcquisitionRegionTop
                EvalProp:
                    prop<<camera.frameGrabberAcquisitionRegionRight
                EvalProp:
                    prop<<camera.frameGrabberAcquisitionRegionBottom
                EvalProp:
                    prop<<camera.numImageBuffers
                EvalProp:
                    prop<<camera.shotsPerMeasurement

enamldef Andor(Window):
    attr camera
    attr analysis

    title = 'Andor Camera'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                MPLCanvas:
                    figure << analysis.figure
                HGroup:
                    PushButton:
                        text = 'video mode'
                        clicked :: camera.setup_video_thread(analysis)
                    PushButton:
                        text = 'stop video'
                        clicked :: camera.stop_video()
                LabelBox:
                    text = 'enable'
                    checked := camera.enable
                EvalProp:
                    prop << camera.EMCCDGain
                EvalProp:
                    prop << camera.preAmpGain
                EvalProp:
                    prop << camera.exposureTime
                ComboBox:
                    items = ['Edge', 'Level']
                    index := camera.triggerMode
                EvalProp:
                    prop<<camera.shotsPerMeasurement
                Form:
                    Label:
                        text = 'shot'
                    SpinBox: shot:
                        minimum=0
                        value := analysis.shot

                        

            
enamldef PICam(Window):
    attr camera
    attr analysis

    title = 'Princeton Instruments Camera'
    Container:
        padding = 0
        ScrollArea:
            Container:
                HGroup:
                    align_widths = False
                    MPLCanvas:
                        figure << analysis.figure
                    Slider:
                        orientation = 'vertical'
                        tracking = False
                        value := camera.roilowv
                        value :: camera.setSendROIvalues()
                        minimum << camera.roimaxv
                        maximum = 0
                    Slider:
                        orientation = 'vertical'
                        tracking = False
                        value := camera.roihighv
                        value :: camera.setSendROIvalues()
                        minimum << camera.roimaxv
                        maximum = 0
                Slider:
                    tracking = False
                    value := camera.roilowh
                    value :: camera.setSendROIvalues()
                    minimum = 0
                    maximum << camera.roimaxh
                Slider:
                    tracking = False
                    value := camera.roihighh
                    value :: camera.setSendROIvalues()
                    minimum = 0
                    maximum << camera.roimaxh
                HGroup:
                    PushButton:
                        text = 'video mode'
                        clicked :: camera.setup_video_thread(analysis)
                    PushButton:
                        text = 'stop video'
                        clicked :: camera.stop_video()
                    PushButton:
                        text = 'Start Server'
                        clicked :: camera.start_server()
                LabelBox:
                    text = 'enable'
                    checked := camera.enable
                EvalProp:
                    prop << camera.AdcEMGain
                #EvalProp:
                #    prop << camera.preAmpGain
                EvalProp:
                    prop << camera.exposureTime
                ComboBox:
                    items = ['Edge', 'Level', 'Auto']
                    index := camera.triggerMode
                EvalProp:
                    prop<<camera.shotsPerMeasurement
                LabelBox:
                    text = 'Average measurements for each iteration'
                    checked := camera.averagemeasurements
                    checked >> analysis.averagemeasurements
                Form:
                    Label:
                        text = 'shot'
                    SpinBox: shot:
                        minimum=0
                        value := analysis.shot 
                LabelBox:
                    text = 'Use Demo Camera'
                    checked := camera.useDemo
                        
                        

enamldef FiltersPage(Page):
    title = 'Filters'

enamldef AOequation(StackItem):
    attr item
    Container:
        hug_height='strong'
        hug_width='strong'
        GroupBox:
            flat=True
            title='description'
            Field:
                constraints=[width==500]
                text:=item.description
                placeholder='description'
        GroupBox:
            flat=True
            title='function'
            Field:
                constraints=[width==500]
                text:=item.function
                placeholder='function that evaluates to a 1D array, where t will be replaced with AO.timesteps'

enamldef AnalogOutput(Window):
    attr AO

    title = 'Analog Output'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                LabelBox: e1:
                    text='enable'
                    checked:=AO.enable
                EvalProp: e2:
                    prop<<AO.physicalChannels
                Form:
                    Label: text = 'number of channels'
                    IntField: value := AO.numChannels
                    Label: text = 'channel descriptions'
                    Field: text := AO.channel_descriptions
                EvalProp: e3:
                    prop<<AO.minimum
                EvalProp: e4:
                    prop<<AO.maximum
                EvalProp: e5:
                    prop<<AO.clockRate
                EvalProp: e6:
                    prop<<AO.units
                EvalProp: e8:
                    prop<<AO.waitForStartTrigger
                EvalProp: e9:
                    prop<<AO.triggerSource
                EvalProp: e10:
                    prop<<AO.triggerEdge
                EvalProp: e11:
                    prop<<AO.exportStartTrigger
                EvalProp: e12:
                    prop<<AO.exportStartTriggerDestination
                EvalProp: e13:
                    prop<<AO.useExternalClock
                EvalProp: e14:
                    prop<<AO.externalClockSource
                EvalProp: e15:
                    prop<<AO.maxExternalClockRate

enamldef AnalogInput(Window):
    attr AI
    attr filters
    attr analysis

    title = 'Analog Input'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='strong'
                hug_width='strong'
                LabelBox:
                    text='enable'
                    checked := AI.enable
                EvalProp:
                    prop << AI.sample_rate
                EvalProp:
                    prop << AI.source
                EvalProp:
                    prop << AI.samples_per_measurement
                EvalProp:
                    prop << AI.waitForStartTrigger
                EvalProp:
                    prop << AI.triggerSource
                EvalProp:
                    prop << AI.triggerEdge
                EvalProp:
                    prop << AI.ground_mode
                NumpyAOchannels:
                    channels<<AI.channels

                # filter
                GroupBox:
                    title = 'Analog Input Filter'
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := filters.enable

                        Label:
                            text = 'What to filter: a string representing a list of [(channel,samples_list,low,high), ...]\nSamples in samples_list will be averaged.'
                        Field:
                            text := filters.what_to_filter

                        Label:
                            text = 'filter level'
                        ComboBox:
                            items = ['None: increment measurement total',
                                     'soft: continue with other analyses, but do not increment measurement total',
                                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
                            index := filters.filter_level

                        Label:
                            text = 'Status'
                        Label:
                            text := filters.text

                # cumulative plot of noise eater data
                GroupBox:
                    title = 'Analog Input plots'
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := analysis.enable
                        Label:
                            text = 'specify what to graph with a list of tuples: [(channel,samples_list),(channel, samples_list)...]\nSamples in samples_list will be averaged.'
                        Field:
                            text := analysis.list_of_what_to_plot
                    PushButton:
                        text = 'clear'
                        clicked :: analysis.clear()
                    MPLCanvas: canvas:
                        constraints=[(height==500)|'strong']
                        hug_width='ignore'
                        figure << analysis.figure


enamldef Counters(Window):
    attr counters

    title = 'Counters'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='strong'
                hug_width='strong'

                LabelBox:
                    text='enable'
                    checked := counters.enable
                IndexedContainer:
                    dynamic = True
                    iterable << counters.counters
                    viewType = Counter


enamldef Counter(Form):
    attr item

    Label: text = 'counter source'
    Field: text := item.counter_source
    Label: text = 'clock source'
    Field: text := item.clock_source
    Label: text = 'clock rate (used for internal source only) [Hz]'
    FloatField: value := item.clock_rate

enamldef DCNoiseEaterChannel(Container):
    attr item

    Form:
        Label:
            text = 'Set: Allow settings on computer to overwrite those on noise eater'
        CheckBox:
            checked := item.update
        Label:
            text = 'Get: Allow settings on noise eater to overwrite those on computer'
        CheckBox:
            checked := item.allow_get

        # variables from DC noise eater
        # read/write variables
        Label:
            text = 'mode'
        ComboBox:
            items = ['off', 'run', 'idle-hi', 'idle-med', 'idle-lo', 'ramp']
            index := item.mode
        Label:
            text = 'trigger warning?'
        CheckBox:
            checked := item.warnSetting
        Label:
            text = 'limit range'
        IntField:
            value := item.limitRange
        Label:
            text = 'invert'
        CheckBox:
            checked := item.invert
        Label:
            text = 'integration time'
        IntField:
            value := item.integrationTime
        Label:
            text = 'trigger number'
        SpinBox:
            minimum = 0
            maximum = 3
            value := item.trigNum
        Label:
            text = 'measurements to average'
        IntField:
            value := item.measNum
        Label:
            text = 'Kp'
        EvalProp:
            prop << item.kp
        Label:
            text = 'Ki'
        EvalProp:
            prop << item.ki
        Label:
            text = 'setpoint'
        IntField:
            value := item.setpoint

        # read only
        Label:
            text = 'average'
        IntField:
            value << item.average
            enabled = False
        Label:
            text = 'error'
        IntField:
            value << item.error
            enabled = False
        Label:
            text = 'V in'
        IntField:
            value << item.vin
            enabled = False
        Label:
            text = 'V out'
        IntField:
            value << item.vout
            enabled = False
        Label:
            text = 'warning'
        CheckBox:
            checked << item.warning
            enabled = False

enamldef DCNoiseEater(Container):
    # represents an individual noise eater box
    attr item

    hug_height='strong'
    hug_width='strong'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := item.enable
        Label:
            text = 'COM port'
        Field:
            text := item.comport

    IndexedContainer:
        dynamic = False
        iterable << item.channels
        viewType = DCNoiseEaterChannel

enamldef DCNoiseEaters(Window):
    # creates an indexed display of the noise eater list
    attr DC_noise_eaters
    attr analysis
    attr filters

    title = 'DC Noise Eaters'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    LabelBox:
                        text = 'enable'
                        checked := DC_noise_eaters.enable

                    IndexedContainer:
                        iterable << DC_noise_eaters.boxes
                        viewType = DCNoiseEater

                # filter
                GroupBox:
                    title = 'DC Noise Eater Filter'
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := filters.enable

                        Label:
                            text = 'What to filter: a string representing a list of [(box,channel,variable,low,high), ...]'
                        Field:
                            text := filters.what_to_filter

                        Label:
                            text = 'filter level'
                        ComboBox:
                            items = ['None: increment measurement total',
                                     'soft: continue with other analyses, but do not increment measurement total',
                                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
                            index := filters.filter_level

                        Label:
                            text = 'Status'
                        Label:
                            text := filters.text

                # cumulative plot of noise eater data
                GroupBox:
                    title = 'DC Noise Eater plots'
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := analysis.enable
                        Label:
                            text = 'specify box, channel and variable (see indices below) to graph with a list of tuples: [(box,channel,variable),(box,channel,variable)]\n 0:mode, 1:warnSetting, 2:limitRange, 3:invert, 4:integrationTime, 5:trigNum, 6:measNum, 7:kp, 8:ki, 9:setpoint, 10:average, 11:error, 12:vin, 13:vout, 14:warning'
                        Field:
                            text := analysis.list_of_what_to_plot
                    PushButton:
                        text = 'clear'
                        clicked :: analysis.clear()
                    MPLCanvas: canvas:
                        constraints=[(height==500)|'strong']
                        hug_width='ignore'
                        figure << analysis.figure

enamldef Arroyo(Window):
    attr experiment
    style_class << 'valid' if experiment.valid else 'invalid'

    title = 'Arroyo'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height = 'strong'
                hug_width = 'strong'

enamldef PiezoChannel(Container):
    attr channel
    
    hug_height = 'strong'
    hug_width = 'strong'
    constraints=[hbox(description, setServo,setPosition,label)]
    Field: description:
        placeholder='description'
        text:=channel.description
    EvalProp: setServo:
        prop<<channel.setServo
    EvalProp: setPosition:
        prop<<channel.setPosition
    GroupBox: label:
        flat=True
        title='read from piezo'
        Label:
            text<<'axis:{}\tservo:{}\tposition:'.format(channel.readAxis,channel.readServo,channel.readPosition)

enamldef PiezoController(StackItem):
    attr item
    
    Container:
        hug_height = 'strong'
        hug_width = 'strong'
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
            Label:
                text='enable'
            CheckBox:
                checked::item.enable
            Label:
                text='serial number set:'
            Field:
                placeholder='serial number'
                text:=item.serialNumber
            Label:
                text='id:'
            Label:
                text:=item.identificationRead
            Label:
                text='serial number read:'
            Label:
                text:=item.serialNumberRead
        RefreshableLooper:
            iterable<<item.channels
            PiezoChannel:
                channel<<loop_item

enamldef PI_Piezo(Window):
    attr piezo
    style_class << 'valid' if experiment.valid else 'invalid'

    title = 'Physik Instrumente Piezo'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                LabelBox:
                    text='enable'
                    checked:=piezo.enable
                IndexedStack:
                    title='Piezo Controllers'
                    iterable<<piezo.controllers
                    viewType=PiezoController

enamldef AnalysisImage(Container):
    attr analysis
    
    padding=0
    constraints=[(height==550)|'strong',(width==550)|'strong']
    MPLCanvas:
        constraints=[(height==550)|'strong',(width==550)|'strong']
        figure<<analysis.figure

enamldef MultiImage(Window):
    attr experiment
    attr analysis0
    attr analysis2
    attr analysis3

    title = 'Live Images'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Label:
                    text<<analysis3.text

                HGroup:
                    padding = 0
                    spacing = 0
                    align_widths = True

                    Container:
                        MPLCanvas:
                            constraints = [(height==1000)|'strong']
                            figure << analysis0.figure
                        Form:
                            Label:
                                text = 'Show ROIs?'
                            CheckBox:
                                checked := analysis0.showROIs
                            Label:
                                text = 'shot'
                            SpinBox:
                                minimum = 0
                                value := analysis0.shot
                            Label:
                                text = 'subtract background (visual only, does not change data)'
                            CheckBox:
                                checked := analysis0.subtract_background

                    Container:
                        MPLCanvas:
                            constraints = [(height==1000)|'strong']
                            figure << analysis2.figure
                        Form:
                            Label:
                                text = 'enable'
                            CheckBox:
                                checked := analysis2.enable
                            Label:
                                text='Show ROIs?'
                            CheckBox:
                                checked:=analysis2.showROIs
                            Label:
                                text = 'shot'
                            SpinBox:
                                minimum=0
                                value := analysis2.shot
                            Label:
                                text = 'plot ymin'
                            Field:
                                placeholder='blank for autolimit'
                                text := analysis2.min_str
                            Label:
                                text = 'plot ymax'
                            Field:
                                placeholder='blank for autolimit'
                                text := analysis2.max_str
                            Label:
                                text = 'subtract background (visual only, does not change data)'
                            CheckBox:
                                checked := analysis2.subtract_background
                            PushButton:
                                text = 'use this image as background'
                                clicked :: analysis2.set_background()

enamldef ImageBrowser(Window):
    attr experiment
    attr analysis1

    title = 'Past Image Browser'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                MPLCanvas:
                    constraints = [(height==1000)|'strong']
                    figure << analysis1.figure
                Form:
                    Label:
                       text='Show ROIs?'
                    CheckBox:
                        checked:=analysis1.showROIs
                GroupBox:
                    hug_height='strong'
                    hug_width='strong'
                    Looper:
                        iterable << experiment.independentVariables  # analysis1.ivarNames
                        Form:
                            Label:
                                text<<loop_item.name
                            ComboBox:
                                items<<[str(i) for i in loop_item.valueList]  # analysis1.ivarValueLists[loop_index]]
                                index::
                                    analysis1.setIteration(loop_index, index) #send which ivar (loop_index) to update to index
                    Form:
                        Label:
                            text='Measurement'
                        SpinBox:
                            minimum=0
                            maximum=9999999 #a big number
                            value:=analysis1.measurement
                    Form:
                        Label:
                            text='Shot'
                        SpinBox:
                            minimum=0
                            maximum=9999999 #a big number
                            value:=analysis1.shot

enamldef SquareROI(Container):
    attr item
    attr num
    hug_height='strong'
    hug_width='strong'
    constraints=[hbox(l0,f0,f1,f2,f3,f4)]
    Label: l0:
        constraints = [(width==50)|'strong']
        text=str(num)
    MyIntField: f0:
        constraints = [(width==100)|'strong']
        placeholder='left'
        value:=item['left']
    MyIntField: f1:
        constraints = [(width==100)|'strong']
        placeholder='top'
        value:=item['top']
    MyIntField: f2:
        constraints = [(width==100)|'strong']
        placeholder='right'
        value:=item['right']
    MyIntField: f3:
        constraints = [(width==100)|'strong']
        placeholder='bottom'
        value:=item['bottom']
    MyFloatField: f4:
        constraints = [(width==100)|'strong']
        placeholder='threshold'
        value:=item['threshold']

enamldef SquareROIContainer(Window):
    attr experiment
    attr analysis

    title = 'Square ROIs'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='ignore'
                hug_width='ignore'
                constraints=[hbox(dynoCont,canvas),align('top',dynoCont,canvas)]
                Container: dynoCont:
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := analysis.enable
                    Container:
                        hug_height='strong'
                        hug_width='strong'
                        constraints=[hbox(l0,l1,l2,l3,l4,l5)]
                        Label: l0:
                            constraints = [(width==50)|'strong']
                            text = 'ROI#'
                        Label: l1:
                            constraints = [(width==100)|'strong']
                            text = 'left'
                        Label: l2:
                            constraints = [(width==100)|'strong']
                            text = 'top'
                        Label: l3:
                            constraints = [(width==100)|'strong']
                            text = 'right'
                        Label: l4:
                            constraints = [(width==100)|'strong']
                            text = 'bottom'
                        Label: l5:
                            constraints = [(width==100)|'strong']
                            text = 'threshold'
                    Include: dyno:
                        objects<<[SquareROI(item=x,num=i) for i,x in enumerate(analysis.ROIs)]
                MPLCanvas: canvas:
                    constraints=[(height==1000)|'strong',(width==1000)|'strong']
                    hug_width='ignore'
                    figure<<analysis.figure

enamldef GaussianROI(Window):
    attr analysis

    title = 'Gaussian ROIs'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'perform gaussian grid fit'
                    CheckBox:
                        checked := analysis.enable_grid_fit
                    Label:
                        text = 'automatically use ROIs from valid fits'
                    CheckBox:
                        checked := analysis.automatically_use_rois
                    Label:
                        text = 'calculate gaussian ROI sums'
                    CheckBox:
                        checked := analysis.enable_calculate_sums
                    Label:
                        text = 'shot'
                    SpinBox:
                        value := analysis.shot
                    Label:
                        text = 'subtract background?'
                    CheckBox:
                        checked := analysis.subtract_background
                    Label:
                        text = 'subtract background from sums?'
                    CheckBox:
                        checked := analysis.subtract_background_from_sums
                    Label:
                        text = 'multiply sums by photoelectron scaling?'
                    CheckBox:
                        checked :=analysis.multiply_sums_by_photoelectron_scaling
                    Label:
                        text = 'clean up image with ICA?'
                    CheckBox:
                        checked := analysis.useICA
                    PushButton:
                        text = "use these ROIs"
                        clicked :: analysis.use_current_rois()
                HGroup:
                    align_widths = False
                    Label:
                        text = 'initial guess'
                    Label:
                        text = 'top'
                    FloatField:
                        value := analysis.top
                    Label:
                        text = 'left'
                    FloatField:
                        value := analysis.left
                    Label:
                        text = 'bottom'
                    FloatField:
                        value := analysis.bottom
                    Label:
                        text = 'right'
                    FloatField:
                        value := analysis.right
                MPLCanvas:
                    figure<<analysis.figure

enamldef LoadingFilters(GroupBox):
    attr filters
    title = 'Region of Interest Sum (Loading) Filters'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := filters.enable

        Label:
            text = 'A boolean expression that evaluates the filter.\nUse t[shot,region] for the summation over any shot and region.\nFor example to require that sites 15 and 17 load: t[0,17]>20000 and t[0,15]>21000'
        Field:
            text := filters.filter_expression
            style_class << 'valid' if filters.valid else 'invalid'

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

        Label:
            text = 'Status'
        Label:
            text := filters.text

enamldef FirstMeasurementsFilter(GroupBox):
    attr filters
    title = 'Drop First N Measurements Filter'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := filters.enable

        Label:
            text = 'How many measurements should we drop at the beginning of each iteration?'
        SpinBox:
            minimum = 0
            value := filters.N

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

enamldef Histogram(Window):
    attr experiment
    attr analysis

    title = 'Histogram'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
                    Field:
                        text := analysis.list_of_what_to_plot
                MPLCanvas:
                    figure<<analysis.figure

enamldef HistogramGrid(Window):
    attr experiment
    attr analysis

    title = 'Histogram Grid'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'shot to display'
                    SpinBox:
                        value := analysis.shot
                    Label:
                        text = 'roi type'
                    ComboBox:
                        items = ['square','gaussian']
                        index := analysis.roi_type
                    Label:
                        text = 'calculate new cutoffs'
                    CheckBox:
                        checked := analysis.calculate_new_cutoffs
                    Label:
                        text = 'automatically use new cutoffs'
                    CheckBox:
                        checked := analysis.automatically_use_cutoffs
                    Label:
                        text = 'cutoff shot mapping list: [shot 0, shot 1, ...] (i.e. [1, 1] to always use shot 1 cutoffs)'
                    Field:
                        text := analysis.cutoff_shot_mapping
                    PushButton:
                        text = 'use new cutoffs'
                        clicked ::
                            analysis.use_cutoffs()
                MPLCanvas:
                    figure<<analysis.figure

enamldef MeasurementsGraph(Window):
    attr experiment
    attr analysis

    title = 'Measurements Graph'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
                    Field:
                        text := analysis.list_of_what_to_plot
                    PushButton:
                        text = 'clear'
                        clicked :: analysis.clear()
                MPLCanvas:
                    figure << analysis.figure

enamldef IterationsGraph(Window):
    attr experiment
    attr analysis

    title = 'Iterations Graphs'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
                    Field:
                        text := analysis.list_of_what_to_plot
                    Label:
                        text = 'update every measurement? (if not, only update at end of iteration)'
                    CheckBox:
                        checked := analysis.update_every_measurement
                        enabled = False
                HGroup:
                    align_widths = False
                    Label: l5:
                        text = 'enable'
                    CheckBox: cb5:
                        checked := analysis.enable
                    Label: l0:
                        text = 'draw connecting lines'
                    CheckBox: cb0:
                        checked := analysis.draw_connecting_lines
                    Label: l1:
                        text = 'draw error bars (1 sigma std dev of mean)'
                    CheckBox: cb1:
                        checked := analysis.draw_error_bars
                    Label: l2:
                        text = 'only add data that has passed loading filter'
                    CheckBox: cb2:
                        checked := analysis.add_only_filtered_data
                    Label: l3:
                        text = 'plot ymin'
                    Field: f3:
                        placeholder='blank for autolimit'
                        text := analysis.ymin
                    Label: l4:
                        text = 'plot ymax'
                    Field: f4:
                        placeholder='blank for autolimit'
                        text := analysis.ymax
                MPLCanvas:
                    figure<<analysis.figure

enamldef RetentionGraph(Window):
    attr experiment
    attr analysis

    title = 'Retention Graph'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'specify regions to graph with a list: [region1, region2]'
                    Field:
                        text := analysis.list_of_what_to_plot
                HGroup:
                    align_widths = False
                    Label: l5:
                        text = 'enable'
                    CheckBox: cb5:
                        checked := analysis.enable
                    Label: l0:
                        text = 'draw connecting lines'
                    CheckBox: cb0:
                        checked := analysis.draw_connecting_lines
                    Label: l1:
                        text = 'draw error bars (1 sigma binomial std dev of mean using normal approximation)'
                    CheckBox: cb1:
                        checked := analysis.draw_error_bars
                    Label: l2:
                        text = 'only add data that has passed loading filter'
                    CheckBox: cb2:
                        checked := analysis.add_only_filtered_data
                    Label: l3:
                        text = 'plot ymin'
                    Field: f3:
                        placeholder='blank for autolimit'
                        text := analysis.ymin
                    Label: l4:
                        text = 'plot ymax'
                    Field: f4:
                        placeholder='blank for autolimit'
                        text := analysis.ymax
                MPLCanvas:
                    figure<<analysis.figure

enamldef Ramsey(Window):
    attr analysis

    title = 'Ramsey analysis'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'draw error bars (1 sigma binomial std dev of mean using normal approximation)'
                    CheckBox:
                        checked := analysis.draw_error_bars
                    Label:
                        text = 'roi'
                    SpinBox:
                        value := analysis.roi
                    Label:
                        text = 'time variable name'
                    Field:
                        text := analysis.time_variable_name
                GroupBox:
                    title = 'fit'
                    constraints=[grid([z0,z1,z2],[a0,a1,a2],[b0,b1,b2],[c0,c1,c2],[d0,d1,d2])]
                    Label: z0:
                        text = 'variable'
                    Label: z1:
                        text = 'guess'
                    Label: z2:
                        text = 'fit'
                    Label: a0:
                        text = 'amplitude'
                    FloatField: a1:
                        value := analysis.amplitude_guess
                    FloatField: a2:
                        value := analysis.amplitude
                        read_only = True
                    Label: b0:
                        text = 'frequency'
                    FloatField: b1:
                        value := analysis.frequency_guess
                    FloatField: b2:
                        value := analysis.frequency
                        read_only = True
                    Label: c0:
                        text = 'offset'
                    FloatField: c1:
                        value := analysis.offset_guess
                    FloatField: c2:
                        value := analysis.offset
                        read_only = True
                    Label: d0:
                        text = 'decay'
                    FloatField: d1:
                        value := analysis.decay_guess
                    FloatField: d2:
                        value := analysis.decay
                        read_only = True
                MPLCanvas:
                    figure<<analysis.figure

enamldef TTL_filters(GroupBox):
    attr instrument
    attr filters
    title = 'TTL (Laser Lock Monitor) Filters'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := instrument.enable

        Label:
            text = 'lines'
        Field:
            text := instrument.lines

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

        Label:
            text = 'Status'
        Label:
            text := filters.text

def get_num_optimization_variables(experiment):
    try:
        return len(experiment.optimizer.optimization_variables)
    except:
        return 0

enamldef Optimizer(Window):
    attr experiment
    attr analysis

    title = 'Optimizer'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable override (to optimize, enable here and on independent variables'
                    CheckBox:
                        checked := analysis.enable_override

                    Label:
                        text = 'enabled?'
                    CheckBox:
                        checked << analysis.enable_gui
                        enabled = False

                    Label:
                        text='update method'
                    ComboBox:
                        items = ['Nelder-Mead', 'genetic', 'gradient descent', 'weighted Nelder-Mead']
                        index := analysis.optimization_method

                    # For the gradient method, the initial step size for each variable is used for determining the gradient.
                    # We need a separate step size that multiplies the gradient
                    Conditional:
                        condition << (analysis.optimization_method == 2)
                        Label:
                            text = 'Initial gradient step size (fraction)'
                        FloatField:
                            value := analysis.line_search_initial_step
                        Label:
                            text='End when step size is less than (fraction)'
                        FloatField:
                            value := analysis.end_condition_step

                    Label:
                        text='cost function'
                    MultilineField:
                        #constraints=[height==300]
                        text:=experiment.optimizer.cost_function

                    Label:  text = 'starting cost'
                    Label:  text << analysis.yi0_str

                    Label:  text = 'best cost'
                    Label:  text << analysis.best_yi_str

                    Label:  text = 'current cost'
                    Label:  text << analysis.yi_str

                    Label: text = 'best experiment number'
                    Label: text << analysis.best_experiment_number_str

                MPLCanvas: canvas:
                    constraints << [(height==150*(len(experiment.independentVariables)+1))|'strong'] #,(width==1000)|'strong']
                    figure << analysis.figure

enamldef Picomotor(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text = 'serial number'
        Field:
            text := item.serial_number
        Label:
            text = 'motor number'
        Field:
            text := item.motor_number
        Label:
            text = 'position'
        EvalProp:
            prop << item.desired_position

enamldef Picomotors(Window):
    attr picomotors

    title = 'Picomotors'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := picomotors.enable
                        Label:
                            text = 'IP Address'
                        Field:
                            text := picomotors.IP
                        Label:
                            text = 'port'
                        IntField:
                            value := picomotors.port

                    IndexedContainer:
                        iterable << picomotors.motors
                        viewType = Picomotor


enamldef Instek_PST(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text := 'serial number: {}'.format(item.serial_number)
        EvalProp:
            prop << item.com_port
        EvalProp:
            prop << item.tracking
        Container:
            constraints = [
                vbox(
                    hbox(Ch1V, Ch1A),
                    hbox(Ch2V, Ch2A),
                    hbox(Ch3V, Ch3A)
                )
            ]
            hug_width = 'strong'
            hug_height = 'strong'
            EvalProp: Ch1V:
                prop << item.voltage_setpoint_1
            EvalProp: Ch1A:
                prop << item.current_setpoint_1
            EvalProp: Ch2V:
                prop << item.voltage_setpoint_2
            EvalProp: Ch2A:
                prop << item.current_setpoint_2
            EvalProp: Ch3V:
                prop << item.voltage_setpoint_3
            EvalProp: Ch3A:
                prop << item.current_setpoint_3    
        Label:
            text = ""
        Container:
            constraints = [
                vbox(
                    hbox(Ch1Va, Ch1Aa),
                    hbox(Ch2Va, Ch2Aa),
                    hbox(Ch3Va, Ch3Aa)
                )
            ]
            hug_width = 'strong'
            hug_height = 'strong'
            Label: Ch1Va:
                text := 'Channel 1 Voltage: {}'.format(item.actual_voltage_1)
            Label: Ch1Aa:
                text := 'Channel 1 Current: {}'.format(item.actual_current_1)
            Label: Ch2Va:
                text := 'Channel 2 Voltage: {}'.format(item.actual_voltage_2)
            Label: Ch2Aa:
                text := 'Channel 2 Current: {}'.format(item.actual_current_2)
            Label: Ch3Va:
                text := 'Channel 3 Voltage: {}'.format(item.actual_voltage_3)
            Label: Ch3Aa:
                text := 'Channel 3 Current: {}'.format(item.actual_current_3)
        PushButton: UpdateNow:
            text = 'Update Now'
            clicked :: item.update()

enamldef Instek_PSTs(Window):
    attr instek_psts

    title = 'Instek PST Power Supplies'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := instek_psts.enable

                    IndexedContainer:
                        iterable << instek_psts.motors
                        viewType = Instek_PST


enamldef Filters(Window):
    attr experiment

    title = 'Filters'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                TTL_filters:
                    instrument = experiment.LabView.TTL
                    filters = experiment.TTL_filters
                LoadingFilters:
                    filters = experiment.loading_filters
                FirstMeasurementsFilter:
                    filters = experiment.first_measurements_filter

enamldef BoxTemperature(Window):
    attr box_temperature

    title = 'Laird Temperature Controllers'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := box_temperature.enable
                    Label:
                        text = 'IP address'
                    Field:
                        text := box_temperature.IP
                    Label:
                        text = 'port'
                    IntField:
                        value := box_temperature.port
                    Label:
                        text = 'connected'
                    CheckBox:
                        checked << box_temperature.connected
                        enabled = False

enamldef PID(Window):
    attr experiment

    title = 'PID servo controller'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                pass

def loadIcon():
    #create icon
    with open(os.path.join('icons','2013_11_14_15_18_54_retention_PCA_filtered_image_rotated_smoothed.png'), 'rb') as f:
        data = f.read()
    image = Image(data=data)
    icon = Icon(images=[IconImage(image=image)])
    return icon

template ScrollPage(Title, Content):
    Page:
        alias content
        title = Title
        style_class << 'valid' if experiment.valid else 'invalid'
        Container:
            padding = 0
            style_class << 'valid' if experiment.valid else 'invalid'
            ScrollArea:
                style_class << 'valid' if experiment.valid else 'invalid'
                Content: content:
                    pass

template ScrollWindow(Title, Content):
    Window:
        alias content
        style_class << 'valid' if experiment.valid else 'invalid'
        Container:
            padding = 0
            style_class << 'valid' if experiment.valid else 'invalid'
            ScrollArea:
                style_class << 'valid' if experiment.valid else 'invalid'
                Content: content:
                    pass

enamldef RetentionAnalysis(Window):
    attr analysis

    title = 'Retention Analysis'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'roi type'
                    ComboBox:
                        items = ['square','gaussian']
                        index := analysis.roi_type
                    Label:
                        text << analysis.text

window_dictionary = {'':'',
                     'Experiment': 'ExperimentPage(experiment = main.experiment)',
                     'Independent Variables': 'IndependentVariables(independentVariables = main.experiment.independentVariables)',
                     'Constants and Dependent Vars': 'Variables(experiment = main.experiment)',
                     'Report': 'Reports(experiment = main.experiment)',
                     'PXI Communication': 'LabViewPage(LabView = main.experiment.LabView)',
                     'HSDIO Digital Output': 'HSDIO_DigitalOutPage(HSDIO = main.experiment.LabView.HSDIO)',
                     'DAQmx Digital Output': 'DAQmxDigitalOutPage(DAQmx = main.experiment.LabView.DAQmxDO)',
                     'DDS': 'DDS_Page(DDS = main.experiment.DDS)',
                     'RF Generators': 'RFGenPage(LabView = main.experiment.LabView)',
                     'Hamamatsu': 'CameraPage(camera = main.experiment.LabView.camera)',
                     'Andor': 'Andor(camera = main.experiment.Andor, analysis=main.experiment.andor_viewer)',
                     'Princeton Instruments Camera': 'PICam(camera = main.experiment.PICam, analysis=main.experiment.picam_viewer)',
                     'Analog Output': 'AnalogOutput(AO = main.experiment.LabView.AnalogOutput)',
                     'Analog Input': 'AnalogInput(AI = main.experiment.LabView.AnalogInput, filters = main.experiment.AI_filter, analysis = main.experiment.AI_graph)',
                     'Arroyo': 'Arroyo(experiment = main.experiment)',
                     'PI Piezo': 'PI_Piezo(piezo = main.experiment.LabView.piezo)',
                     'Picomotors': 'Picomotors(picomotors = main.experiment.picomotors)',
                     'Instek PST Power Supplies': 'Instek_PSTs(instek_psts = main.experiment.instekpsts)',
                     'Live Images': 'MultiImage(experiment = main.experiment, analysis0 = main.experiment.recent_shot_analysis, analysis2 = main.experiment.imageSumAnalysis, analysis3 = main.experiment.text_analysis)',
                     'Image Browser': 'ImageBrowser(experiment = main.experiment, analysis1 = main.experiment.shotBrowserAnalysis)',
                     'Square ROI':  'SquareROIContainer(experiment = main.experiment, analysis = main.experiment.squareROIAnalysis)',
                     'Gaussian ROI': 'GaussianROI(analysis = main.experiment.gaussian_roi)',
                     'Histogram': 'Histogram(experiment = main.experiment, analysis = main.experiment.histogramAnalysis)',
                     'Histogram Grid': 'HistogramGrid(experiment = main.experiment, analysis = main.experiment.histogram_grid)',
                     'Measurements Graph': 'MeasurementsGraph(experiment = main.experiment, analysis = main.experiment.measurements_graph)',
                     'Iterations Graph': 'IterationsGraph(experiment = main.experiment, analysis = main.experiment.iterations_graph)',
                     'Retention Graph': 'RetentionGraph(experiment = main.experiment, analysis = main.experiment.retention_graph)',
                     'Filters': 'Filters(experiment = main.experiment)',
                     'Optimization': 'Optimizer(experiment = main.experiment, analysis = main.experiment.optimizer)',
                     'DC Noise Eaters': 'DCNoiseEaters(DC_noise_eaters = main.experiment.DC_noise_eaters, analysis = main.experiment.DC_noise_eater_graph, filters = main.experiment.DC_noise_eater_filter)',
                     'Laird Temperature Controllers': 'BoxTemperature(box_temperature = main.experiment.box_temperature)',
                     'Ramsey': 'Ramsey(analysis = main.experiment.Ramsey)',
                     'PID': 'PID(experiment = main.experiment)',
                     'Retention Analysis': 'RetentionAnalysis(analysis = main.experiment.retention_analysis)',
                     'Counters': 'Counters(counters = main.experiment.LabView.Counters)',
                     'Functional Waveforms': 'FunctionalWaveforms(waveforms = main.experiment.functional_waveforms)',
                     'Functional Waveforms Graph': 'FunctionalWaveformsGraph(graph = main.experiment.functional_waveforms_graph)'
                     }
window_keys = window_dictionary.keys()
window_keys.sort()


enamldef Main(MainWindow): main:
    attr experiment

    title='Saffmanlab experiment controller'
    #initial_position=(0,0)
    #initial_size=(1500,1100)
    icon = loadIcon()
    closing :: main.experiment.exiting()

    MyStyleSheet:
        #just implement the style sheet defined separately
        pass
    CsMenuBar:
        experiment=main.experiment
        mainWindow=main
    StatusBar:
        StatusItem:
            Label:
                text << 'Status: {}, Iteration: {}, Measurement: {}, Good Measurements: {}, Progress: {}%'.format(experiment.statusStr,experiment.iterationStr,experiment.measurementStr,experiment.goodMeasurementsStr,experiment.progressGUI)
        StatusItem:
            ProgressBar: progress:
                #constraints=[width==1200]
                minimum=0
                maximum=100
                value<<int(experiment.progressGUI)
                
                
                

    HGroup:
        align_widths = False
        Label: text = 'Select a window to open:'
        PushButton:
            text = 'open'
            clicked ::
                if combo.selected_item != '':
                    new = eval(window_dictionary[combo.selected_item])
                    new.show()
        ComboBox: combo:
            items = window_keys
            index ::
                if selected_item != '':
                    new = eval(window_dictionary[selected_item])
                    new.show()
