"""
author = 'Martin Lichtman'
created = 2013-04-02
modified >= 2014-04-21

cs_GUI.enaml

A GUI for the Cs experiment controller, written using the enaml toolkit for python.
"""

from __future__ import division
__author__ = 'Martin Lichtman'
import logging
logger = logging.getLogger(__name__)

from cs_errors import PauseError

from enaml.layout.api import vbox, hbox, align, horizontal, vertical, spacer, grid
from enaml.widgets.api import (MainWindow, MenuBar, Menu, Action,
                                Notebook, Page, Container, GroupBox, DualSlider, Slider,
                                Form, Label, CheckBox, SpinBox, PushButton, MPLCanvas,
                                MultilineField, ProgressBar, ScrollArea, Separator,
                                FileDialog,Window, StatusBar, StatusItem,
                                Stack, StackItem, ComboBox, HGroup, VGroup
)
from enaml.icon import Icon, IconImage
from enaml.image import Image
from enaml.core.declarative import d_
from enaml.core.include import Include
from enaml.stdlib.fields import FloatField, IntField
from enaml.core.api import Looper, Conditional
from enaml.styling import StyleSheet, Style, Setter
from enaml.validator import Validator
from atom.api import Member, Bool, Typed, observe, Callable
import threading, datetime, time, os, itertools
import numpy, itertools

from experiments import IndependentVariable
from instrument_property import ListProp

# redefine Field so that all Fields will have status_tips
from enaml.widgets.api import Field as OldField
enamldef Field(OldField):
    status_tip << text

enamldef MyStyleSheet(StyleSheet):
    Style:
        style_class = 'invalid'
        Setter:
            field = 'background-color'
            value = 'pink'
        Setter:
            field = 'border-color'
            value = 'red'
        Setter:
            field = 'border-style'
            value = 'solid'
        Setter:
            field = 'border-width'
            value = '2'
    Style:
        style_class = 'valid'

enamldef RefreshableLooper(Looper): self:
    """A Looper that sends a reference of itself to the backend controller, so it can be forcibly updated using the
    refresh_items() method."""
    initialized::
        iterable.gui = self

class MyBoolValidator(Validator):
    experiment=Member()

    def __init__(self,experiment):
        super(MyBoolValidator,self).__init__()
        self.experiment=experiment

    def validate(self,text):
        try:
            value = self.experiment.eval_bool(text)
        except:
            return False
        return True


class MyEnumValidator(Validator):
    experiment=Member()
    allowedValues=Member()

    def __init__(self,experiment,allowedValues):
        super(MyEnumValidator,self).__init__()
        self.experiment=experiment
        self.allowedValues=allowedValues

    def validate(self,text):
        try:
            value = self.experiment.eval_general(text)
        #check for parsing errors
        except:
            return False
        #check if the value is one of the ones allowed by this particular Enum
        if value not in self.allowedValues:
            return False
        #if we've gotten this far, all tests have passed
        return True

#TODO: make these Fields have validation and able to process statements
enamldef MyIntField(Field):
    """This class exists to make an IntField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = int(text)

enamldef MyFloatField(Field):
    """This class exists to make a FloatField that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = float(text)

enamldef MyBoolField(Field):
    """This class exists to make a BoolField (which isn't something that is available anyway),
     that is able to be synced with a numpy array element."""
    attr value
    text << str(value)
    text :: self.value = bool(text)

enamldef IndexedStack(GroupBox): indexedStack:
    attr iterable=Typed(ListProp)
    attr viewType #=Class(StackItem)  #do we really have to declare what type? I suppose this was so that we would be okay with creating an instance
    hug_height = 'strong'
    hug_width = 'strong'

    Container: controls:
        constraints=[hbox(addButton,removeButton,combo)]
        PushButton: addButton:
            text='+'
            constraints=[width==50,height==20]
            clicked::
                iterable.add()
                combo.maximum=len(iterable)-1
                combo.value=combo.maximum
        PushButton: removeButton:
            text='-'
            constraints=[width==50,height==20]
            clicked::
                i=combo.value
                if i>=0:
                    iterable.pop(i)
                    combo.maximum=len(iterable)-1
                    if i>1:
                        combo.value=i-1
                    else:
                        combo.value=0
        # RefreshableComboBox: combo:
            # items<<[str(i)+' '+n.description for i,n in enumerate(iterable)]
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
    Stack: stack:
        index<<combo.value
        RefreshableLooper:
            iterable<<indexedStack.iterable
            Include:
                objects=[viewType(item=loop_item)]

enamldef IndexedContainer(GroupBox):
    # This is like an IndexedStack, but instead of using a stack, we just have only one object to display and we
    # change what that one object is using an Include
    # The attribute 'iterable' must be a ListProp.  This container then provides controls to add and remove elements.
    # The GUI element viewType must define 'item' which is the element of the ListProp that will be passed to it
    # The attribute dynamic enables the buttons to dynamically add or remove list items

    attr iterable = Typed(ListProp)
    # Below is commented out because we don't actually have to declare the type.
    # This was so that we would be okay with creating an instance, but it's not necessary
    attr viewType  # = Class(StackItem)
    # The attribute static disables the buttons to dynamically add or remove list items
    attr dynamic = True

    hug_height = 'strong'
    hug_width = 'strong'

    HGroup:
        #constraints=[hbox(addButton,removeButton,combo)]
        Conditional:
            condition = dynamic
            PushButton: addButton:
                text='Add'
                constraints=[width==50,height==20]
                clicked::
                    iterable.add()
                    combo.maximum=len(iterable)-1
                    combo.value=combo.maximum
            PushButton: removeButton:
                text='Remove'
                constraints=[width==50,height==20]
                clicked::
                    i=combo.value
                    if i>=0:
                        iterable.pop(i)
                        combo.maximum=len(iterable)-1
                        if i>1:
                            combo.value=i-1
                        else:
                            combo.value=0
        SpinBox: combo:
            constraints=[width==50,height==20]
            maximum<<len(iterable)-1
            minimum=0
    # the actual thing to display
    Conditional:
        condition << ((iterable.length>0) and (combo.value >=0))
        Include:
           objects << [viewType(item=iterable[combo.value])]

def get_load_file_callback(experiment):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.load(dlg.path)
            except PauseError:
                pass
    return load_file_callback

def get_save_file_callback(experiment):
    def save_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                experiment.save(dlg.path)
            except PauseError:
                pass
    return save_file_callback

enamldef CsMenuBar(MenuBar): menuBar:
    attr experiment
    attr mainWindow

    Menu:
        title = '&File'
        Action:
            text = 'Load\tCtrl+L'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Choose file to load',
                    mode='open_file',
                    path=experiment.settings_path,
                    callback=get_load_file_callback(experiment),
                    ).open()
        Action:
            text = 'Save\tCtrl+S'
            triggered::
                dlg = FileDialog(
                    parent=menuBar,
                    title='Save As?',
                    mode='save_file',
                    path=os.path.join(experiment.settings_path,'settings-{}.hdf5'.format(datetime.datetime.now().strftime('%Y-%m-%d-%H-%M-%S'))),
                    callback=get_save_file_callback(experiment),
                    ).open()
        Action:
            text = 'Quit\tCtrl+Q'
            triggered::
                mainWindow.close()
    Menu:
        title = '&Experiment'
        Action:
            text = 'Reset and Run\tCtrl+R'
            triggered::experiment.resetAndGo()
        Action:
            text = 'Reset'
            triggered::experiment.reset()
        Action:
            text = 'Run/Continue\tCtrl+G'
            triggered::experiment.goThread()
        Menu:
            title = 'Pause...'
            Action:
                checkable = True
                text = 'After Measurement\tCtrl+M'
                checked := experiment.pauseAfterMeasurement
            Action:
                checkable = True
                text = 'After Iteration'
                checked := experiment.pauseAfterIteration
            Action:
                checkable = True
                text = 'After Error'
                checked := experiment.pauseAfterError
            Action:
                text = 'Now\tCtrl+P'
                triggered :: experiment.pause_now()
        Action:
            text = 'End and Upload'
            triggered::experiment.end_now()
        Action:
            text = 'Upload'
            triggered::experiment.upload_now()
        Action:
            text = 'Stop\tCtrl+H'
            triggered::experiment.stop()
    Menu:
        title = 'Evaluation'
        Action:
            text='Update variables throughout experiment'
            triggered :: experiment.evaluateAll()

enamldef EvalProp(GroupBox):
    attr prop

    padding = 0
    flat = True
    title << prop.name
    constraints = [desc.width==func.width, func.width==val.width, hbox(desc,func,val), align('v_center',desc,func,val)]

    # can be made to show an error status by setting valid to false
    attr valid = True

    Field: desc:
        text := prop.description
        placeholder = 'description'

    Field: func:
        text := prop.function
        placeholder = prop.placeholder
        style_class << 'valid' if prop.valid else 'invalid'

    Label: val:
        text << prop.valueStr

enamldef MultilineProp(GroupBox):
    attr prop
    flat=True
    title:=prop.name
    constraints=[vbox(desc,hbox(func,val)),align('top',func,val)]
    Field: desc:
        text:=prop.description
        placeholder='description'
    MultilineField: func:
        text:=prop.function
    Label: val:
        text << prop.valueStr

enamldef LabelBox(HGroup):
    alias checked: box.checked
    alias text: label.text

    padding=0
    hug_height='strong'
    hug_width='strong'
    align_widths = False

    Label: label:
        pass
    CheckBox: box:
        pass

enamldef CheckField(HGroup):
    alias checked: box.checked
    alias text: field.text
    alias placeholder: field.placeholder

    padding = 0
    hug_height='strong'
    hug_width='strong'
    align_widths = False

    CheckBox: box:
        pass
    Field: field:
        pass

enamldef LabelField(VGroup):
    alias label: l1.text
    alias text: f1.text
    alias placeholder: f1.placeholder

    padding = 0
    hug_height='strong'
    hug_width='strong'

    Label: l1:
        pass
    Field: f1:
        pass

#class RefreshableComboBox(ComboBox):
#    refresh = EnamlEvent

enamldef ExperimentPage(Window):
    attr experiment
    title = 'Experiment'

    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'

            Form: form:
                constraints = [(midline==left)|'strong'] #,(width==parent.contents_width)|'strong']

                Label: text='ROI Rows'
                IntField: value := experiment.ROI_rows
                Label: text='ROI Columns'
                IntField: value := experiment.ROI_columns

                Label: text='ROI Background Rows'
                IntField: value := experiment.ROI_bg_rows
                Label: text='ROI Background Columns'
                IntField: value := experiment.ROI_bg_columns

                Label:
                    text="Status:"
                Label:
                    text<<experiment.statusStr

                Label:
                    text='Pause after iteration'
                CheckBox:
                    checked:=experiment.pauseAfterIteration

                Label:
                    text='Pause after measurement'
                CheckBox:
                    checked:=experiment.pauseAfterMeasurement

                Label:
                    text='Pause after error'
                CheckBox:
                    checked:=experiment.pauseAfterError

                Label:
                    text='Reload settings after pause?'
                CheckBox:
                    checked:=experiment.reload_settings_after_pause

                Label:
                    text='Keep repeating same experiments automatically?'
                CheckBox:
                    checked:=experiment.repeat_experiment_automatically


                Label:
                    text = 'enable sounds'
                CheckBox:
                    checked := experiment.enable_sounds

                Label:
                    text = 'start each instrument in a separate thread'
                CheckBox:
                    checked := experiment.enable_instrument_threads

                Label: text='Save Data?'
                CheckField:
                    checked:=experiment.saveData
                    text:=experiment.localDataPath
                    placeholder='local data path'

                Label: text='Save Settings?'
                CheckBox:
                    checked:=experiment.saveSettings

                Label: text='Save separate notes.txt?'
                CheckBox:
                    checked:=experiment.save_separate_notes

                Label: text='Save 2013 style files?'
                CheckBox:
                    checked:=experiment.save2013styleFiles

                Label: text='Copy Data to Network?'
                CheckField:
                    checked:=experiment.copyDataToNetwork
                    text:=experiment.networkDataPath
                    placeholder='network data path'

                Label: text='Experiment description suffix for filename'
                Field: text:=experiment.experimentDescriptionFilenameSuffix

                Label: text='Measurement Timeout [s]'
                FloatField: value:=experiment.measurementTimeout

                Label: text='Measurements per Iteration'
                IntField: value:=experiment.measurementsPerIteration

                Label: text='E-mail on error/completion?'
                CheckField:
                    checked:=experiment.willSendEmail
                    text:=experiment.emailAddresses

                Label: text='Progress'
                Label: text<<'{}%'.format(experiment.progressGUI)

                Label: text='Iteration'
                Label: text<<experiment.iterationStr

                Label: text='Measurement'
                Label: text<<experiment.measurementStr

                Label: text='Good Measurements'
                Label: text<<experiment.goodMeasurementsStr

                Label: text='Time started'
                Label: text<<experiment.timeStartedStr

                Label: text='Time after last measurement'
                Label: text<<experiment.currentTimeStr

                Label: text='Time elapsed'
                Label: text<<experiment.timeElapsedStr

                Label: text='Estimated total time'
                Label: text<<experiment.totalTimeStr

                Label: text='Estimated time remaining'
                Label: text<<experiment.timeRemainingStr

                Label: text='Estimated completion time'
                Label: text<<experiment.completionTimeStr

                Label: text='Notes'
                MultilineField:
                    text:=experiment.notes

enamldef VariableEntry(GroupBox):
    attr indepVar
    attr list_index

    #hug_height = 'strong'
    #hug_width = 'strong'
    #constraints = [vbox(variable,optimizer1,optimizer2,values,status), align('left',variable,optimizer1,optimizer2,values,status)]

    HGroup: variable:
        align_widths = False
        constraints = [nameCont.width==100, descCont.width==200, funcCont.width==200]
        Label:
            text << list_index
        Field: nameCont:
            text := indepVar.name
            placeholder = 'name'
        Field: descCont:
            text := indepVar.description
            placeholder = 'description'
        Field: funcCont:
            text := indepVar.function
            placeholder = 'function'
        Form:
            Label:
                text = 'optimize?'
            CheckBox:
                checked := indepVar.optimize
        Form:
            Label:
                text = 'initial step (abs)'
            FloatField:
                value := indepVar.optimizer_initial_step
        Form:
            Label:
                text = 'end tolerance (abs)'
            FloatField:
                value := indepVar.optimizer_end_tolerance
        Form:
            Label:
                text = 'min'
            FloatField:
                value := indepVar.optimizer_min
        Form:
            Label:
                text = 'max'
            FloatField:
                value := indepVar.optimizer_max
    HGroup:
        align_widths = False
        Label: values:
            text << 'values: '+indepVar.valueListStr
        Label:
            text << 'step: '+str(indepVar.index)+' of '+str(indepVar.steps)
        Label:
            text = 'current value'
        Field:
            text << indepVar.currentValueStr
            read_only = True

enamldef IndependentVariables(Window):
    attr independentVariables

    title = 'Independent Variables'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:

                Label:
                    text = 'Evaluated after Constants and before Dependents.  Inner loop on top.'

                GroupBox:
                    HGroup:
                        SpinBox: spin0:
                            minimum=0
                            maximum << independentVariables.length
                        PushButton: addButton0:
                            text='+'
                            clicked::
                                independentVariables.add_at(spin0.value)
                        PushButton: removeButton0:
                            text='-'
                            clicked::
                                independentVariables.pop(spin0.value)

                RefreshableLooper:
                    iterable<<independentVariables
                    VariableEntry:
                        indepVar << loop_item
                        list_index << str(loop_index)

enamldef Variables(Window):
    attr experiment

    title = 'Constants and Dependent Variables'

    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container: page:
                style_class << 'valid' if experiment.valid else 'invalid'

                GroupBox: variablesNotToSave:
                    hug_height='strong'
                    title='Variables Not To Save to HDF5 (comma separated)'
                    Field:
                        text:=experiment.variablesNotToSave
                        placeholder='scipy,numpy,x'

                HGroup:
                    constraints = [align('top', constants, dependents), constants.width==dependents.width]

                    GroupBox: constants:
                        title='Constants (Evaluated 1st, before Independents)'

                        Label:
                            text='Define constants using python code below.'
                        MultilineField:
                            constraints = [bottom==page.contents_bottom]
                            text:=experiment.constantsStr

                    GroupBox: dependents:
                        title='Dependent Variables (Evaluated 3rd, after Independents)'

                        Label:
                            text='Define dependent variables using python code below.'
                        MultilineField:
                            constraints = [bottom==page.contents_bottom]
                            text:=experiment.dependentVariablesStr

enamldef Reports(Window):
    attr experiment

    title = 'Reports'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    GroupBox:
                        title = 'Constant Report'
                        hug_height = 'strong'
                        hug_width = 'strong'
                        constraints = [hbox(f1,lb1),align('top',f1,lb1)]
                        MultilineField: f1:
                            constraints = [height==950, width==600]
                            text := experiment.constantReport.function
                            style_class << 'valid' if experiment.constantReport.valid else 'invalid'
                        Label: lb1:
                            text << experiment.constantReport.valueStr
                    GroupBox:
                        title = 'Variable Report'
                        hug_height = 'strong'
                        hug_width = 'strong'
                        constraints = [hbox(f2,lb2),align('top',f2,lb2)]
                        MultilineField: f2:
                            constraints = [height==950, width==600]
                            text := experiment.variableReport.function
                            style_class << 'valid' if experiment.variableReport.valid else 'invalid'
                        Label: lb2:
                            text << experiment.variableReport.valueStr

enamldef LabViewPage(Window):
    attr LabView

    title = 'PXI communication'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='strong'
                Container:
                    constraints=[hbox(b1,b3,b4),b1.width==100,b3.width==100,b4.width==100]
                    PushButton: b1:
                        text='open connection'
                        clicked::
                            LabView.openThread()
                    PushButton: b3:
                        text='update settings'
                        clicked::
                            LabView.update()
                    PushButton: b4:
                        text='close connection'
                        clicked::
                            LabView.close()

                Form:
                    Label:
                        text='enable communication with LabView system?'
                    CheckBox:
                        checked:=LabView.enable
                    Label:
                        text='IP address of LabView system'
                    Field:
                        text:=LabView.IP
                    Label:
                        text='communications port'
                    IntField:
                        value:=LabView.port
                    Label:
                        text='cycle experiment continuously even when not taking data?'
                    CheckBox:
                        checked:=LabView.cycleContinuously
                EvalProp:
                    prop<<LabView.timeout
                Form:
                    Label:
                        text='connected'
                    CheckBox:
                        checked:=LabView.connected
                        enabled=False
                    Label: text='LabView error'
                    Label: text<<str(LabView.error)

                GroupBox:
                    title='TCP output message'
                    constraints = [vbox(scroller1),(height==500)|'strong']
                    hug_width='ignore'
                    ScrollArea:scroller1:
                        Container:
                            hug_height='ignore'
                            hug_width='ignore'
                            Label:
                                hug_height='ignore'
                                hug_width='ignore'
                                text<<LabView.msg

                GroupBox:
                    title='LabView log'
                    constraints = [vbox(scroller2),(height==500)|'strong']
                    hug_width='ignore'
                    ScrollArea: scroller2:
                        Container:
                            hug_height='ignore'
                            hug_width='ignore'
                            Label:
                                hug_height='ignore'
                                hug_width='ignore'
                                text<<LabView.log

enamldef DOchannel(Container):
    attr channel
    attr index
    hug_height='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel.description
        placeholder='description'
    Field: activeF:
        text:=channel.active.function
        placeholder='active?'
    Label: activeL:
        text<<str(channel.active.value)

enamldef HSDIOScriptTrigger(StackItem):
    attr item

    Container:
        padding=0
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
        EvalProp:
            prop<<item.id
        EvalProp:
            prop<<item.source
        EvalProp:
            prop<<item.type
        EvalProp:
            prop<<item.edge
        EvalProp:
            prop<<item.level

enamldef StartTrigger(GroupBox):
    attr trigger
    title='Start Trigger'

    EvalProp:
        prop<<trigger.waitForStartTrigger
    EvalProp:
        prop<<trigger.source
    EvalProp:
        prop<<trigger.edge

class RefreshableMPLCanvas(MPLCanvas):
    """ An MPLCanvas that can be refreshed on command by toggling refresh.
    Requires adding a function to MPLCanvas in
    C:\Users\Saffmanlab\AppData\Local\Enthought\Canopy\User\Lib\site-packages\enaml\qt\qt_mpl_canvas.py:
        def on_action_set_refresh(self, content):
            self.refresh_mpl_widget()
    """

    #: Toggle this to refresh the canvas
    refresh = d_(Bool())

class RemoveEventContainer(Container):
    remove=d_(Bool())

enamldef NumpyAOchannel(Container):
    attr channel
    attr index

    hug_height='strong'
    hug_width='strong'
    padding=0
    Form:
        Label: text=str(index)
        Field:
            text:=channel['description']
            placeholder='description'

enamldef NumpyAOchannels(GroupBox):
    attr channels
    title='channels (#, description)'
    hug_height='strong'
    hug_width='strong'
    Container: controls:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton,removeButton)]
        SpinBox: spin0:
            minimum=0
            maximum<<len(channels.array)
        PushButton: addButton:
            text='+'
            clicked::
                channels.add(spin0.value)
        PushButton: removeButton:
            text='-'
            clicked::
                channels.remove(spin0.value)
    Container:
        Include:
            objects<<[NumpyAOchannel(channel=x,index=i) for i,x in enumerate(channels.array)]


enamldef NumpyDOchannel(Container):
    attr channel
    attr index
    attr digitalout #the DAQmxDO or HSDIO
    attr experiment

    hug_height='strong'
    hug_width='strong'
    padding=0
    constraints=[label.width==25,description.width==3*activeF.width,activeF.width==2*activeL.width,hbox(label,description,activeF,activeL,),align('v_center',label,description,activeF,activeL)]
    Label: label:
        text=str(index)
    Field: description:
        text:=channel['description']
        placeholder='description'
    Field: activeF:
        text:=channel['function']
        placeholder='active?'
        validator<<MyBoolValidator(experiment)
        text::
            channel['value']=experiment.eval_bool(text)
            activeL.text=str(channel['value']) #must be updated manually because the channel['value'] identity does not change
            digitalout.evaluate()
    Label: activeL:
        text<<str(channel['value'])

enamldef NumpyDOchannels(GroupBox):
    attr channels
    title='channels (#, description, active?)'
    hug_height='strong'
    hug_width='strong'
    #constraints=[controls.left==dynoCont.left]
    Container: controls:
        hug_height='strong'
        hug_width='strong'
        constraints=[hbox(spin0,addButton,removeButton)]
        SpinBox: spin0:
            minimum=0
            maximum<<len(channels.array)
        PushButton: addButton:
            text='+'
            clicked::
                channels.add(spin0.value)
        PushButton: removeButton:
            text='-'
            clicked::
                channels.remove(spin0.value)
    Container: dynoCont:
        Include: dyno:
            objects<<[NumpyDOchannel(channel=x,index=i,digitalout=channels.digitalout,experiment=channels.experiment) for i,x in enumerate(channels.array)]

enamldef NumpyState(Form):
    attr state
    attr experiment
    attr waveform
    attr value_str
    attr valid

    padding=0

    Field:
        constraints = [width == 100,height==20]
        style_class << 'valid' if valid else 'invalid'
        text:=state['function']
        text::
            value, parent.valid = experiment.eval_general(text)
            if value is None:
                state['value'] = 5
                parent.value_str = ''
            elif (value == 0) or (value ==1):
                state['value'] = value
                parent.value_str = str(state['value']) #must be updated manually because state['value'] identity does not change
            else:
                logger.warning('Invalid state in waveform {}.  States must evaluate to None, 0 or 1.\n{} = {}'.format(waveform.name,text,value))
                state['value'] = 5
                parent.value_str = ''
                parent.valid = False
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width==50, height==20]
        text << value_str

enamldef ChannelCombo(ComboBox):
    attr wfm
    attr channels
    attr channelList
    attr position

    items<<[str(i)+' '+x for i,x in enumerate(channels.array['description'])]
    index<<int(channelList[position])
    index::
        channelList[position]=numpy.uint8(index)
        wfm.updateFigure()

enamldef TransitionsLabel(Container):
    padding=0
    Label:
        constraints = [height == 20]
        text='description'
    Label:
        constraints = [height == 20]
        text='time'

enamldef DescriptionLabel(Label):
    constraints = [height == 20]
    text='description'

enamldef TimeLabel(Label):
    constraints = [height == 20]
    text='time'

enamldef TransitionDescription(Field):
    attr transition
    constraints = [height==20]
    placeholder = 'description'
    text:=transition['description']

enamldef TransitionTime(Form):
    attr experiment
    attr waveform
    attr transition
    attr value_str
    attr valid

    padding=0

    Field:
        constraints = [width == 100, height==20]
        placeholder = 'time'
        text := transition['function']
        style_class << 'valid' if valid else 'invalid'
        text::
            transition['value'], parent.valid = experiment.eval_float(text)
            value_str = '{:.6f}'.format(transition['value']) #must be updated manually because transition['value'] identity does not change
            waveform.updateFigure()
    Label: valueLabel:
        constraints = [width==50, height==20]
        text << value_str

enamldef NumpyWaveform(Container):
    attr waveform

    hug_height='strong'
    hug_width='ignore'
    constraints=[vbox(plotcontrols,details),align('left',plotcontrols,details)]

    Container: plotcontrols:
        hug_width='strong'
        hug_height='strong'
        constraints=[hbox(lmin,plotmin,lmax,plotmax)]
        padding=0
        Label: lmin:
            text='plot min'
        Field: plotmin:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmin=-1
                else:
                    waveform.plotmin=float(text)
                waveform.updateFigure()
        Label: lmax:
            text='plot max'
        Field: plotmax:
            placeholder='blank for autolimit'
            text::
                if text=='':
                    waveform.plotmax=-1
                else:
                    waveform.plotmax=float(text)
                waveform.updateFigure()

    Container: details:
        constraints=[vbox(hbox(nameField,timeControls,channelControls),transitions)]
        hug_height='strong'
        hug_width='strong'

        Field: nameField:
            constraints = [width == 150, height == 20]
            text:=waveform.name

        GroupBox: timeControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l0,spin0,addButton0,removeButton0)]
            Label: l0:
                text='times'
            SpinBox: spin0:
                minimum=0
                maximum<<len(waveform.transitions.array)
            PushButton: addButton0:
                text='+'
                clicked::
                    waveform.addTransition(spin0.value)
            PushButton: removeButton0:
                text='-'
                clicked::
                    waveform.removeTransition(spin0.value)

        GroupBox: channelControls:
            hug_height='strong'
            hug_width='strong'
            constraints=[hbox(l1,spin1,addButton1,removeButton1)]
            Label: l1:
                text='channels'
            SpinBox: spin1:
                minimum=0
                maximum<<len(waveform.channelList)
            PushButton: addButton1:
                text='+'
                clicked::
                    waveform.addChannel(spin1.value)
            PushButton: removeButton1:
                text='-'
                clicked::
                    waveform.removeChannel(spin1.value)
        GroupBox: transitions:
            hug_height='strong'
            hug_width='strong'
            title='waveform transition and sequence (valid states: blank(continue), 0(off), 1(on))'
            constraints<<[grid(*[statesDyno.objects[i:(i+len(waveform.transitions.array)+1)] for i in range(0, len(statesDyno.objects), len(waveform.transitions.array)+1)])] if len(statesDyno.objects)>0 else []
            Include: statesDyno:
                objects << ([DescriptionLabel()]
                    +[TransitionDescription(transition=t) for t in waveform.transitions.array]
                    +[TimeLabel()]
                    +[TransitionTime(transition=t,experiment=waveform.experiment,waveform=waveform,value_str=value_str,valid=valid) for t,value_str,valid in zip(waveform.transitions.array,waveform.transitions.value_str,waveform.transitions.valid)]
                    +(list(itertools.chain(*map(list,zip(*([[ChannelCombo(wfm=waveform,channels=waveform.digitalout.channels,channelList=waveform.channelList,position=i) for i in xrange(len(waveform.channelList))]]
                    +[[NumpyState(state=s,experiment=waveform.experiment,waveform=waveform,value_str=value_str,valid=valid) for s,value_str,valid in zip(waveform.sequence.array.flat,waveform.sequence.value_str.flat,waveform.sequence.valid.flat)][i:i+len(waveform.channelList)] for i in range(0,waveform.sequence.array.size,len(waveform.channelList))]))))) if (len(waveform.channelList)>0) else [])
                    )

def get_load_waveform_callback(HSDIO):
    def load_file_callback(dlg):
        if dlg.result == 'accepted':
            try:
                HSDIO.import_waveform(dlg.path)
            except PauseError:
                pass
    return load_file_callback

enamldef FunctionalWaveforms(Window):
    attr waveforms

    title = 'Functional Waveform Definitions'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'
                constraints = [enable.left==contents_left, enable.bottom+5==field.top, enable.top==contents_top, field.left==contents_left, field.right==contents_right, field.bottom==contents_bottom]

                LabelBox: enable:
                    text = 'enable'
                    checked := waveforms.enable

                MultilineField: field:
                    # waveform entry
                    hug_width = 'ignore'
                    hug_height = 'ignore'
                    text := waveforms.text

enamldef FunctionalWaveformsGraph(Window):
    attr graph

    title = 'Functional Waveforms Graph'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                constraints = [canvas.top==contents_top, canvas.left==contents_left, canvas.right==contents_right, canvas.bottom+5==controls.top, controls.left==contents_left, controls.bottom==contents_bottom]

                MPLCanvas: canvas:
                    figure << graph.figure

                # plot controls
                HGroup: controls:
                    align_widths = False
                    hug_width='strong'
                    hug_height='strong'
                    padding=0
                    LabelBox:
                        text = 'enable'
                        checked := graph.enable
                    LabelBox:
                        text = 'draw_fig'
                        checked := graph.draw_fig
                    Label: text = 'HSDIO'
                    Field:
                        placeholder = 'HSDIO channels to plot'
                        text := graph.HSDIO_channels_to_plot
                    LabelBox:
                        text = 'HSDIO ticks'
                        checked := graph.draw_HSDIO_ticks
                    Label: text = 'AO'
                    Field:
                        placeholder = 'AO channels to plot'
                        text := graph.AO_channels_to_plot
                    LabelBox:
                        text = 'AO ticks'
                        checked := graph.draw_AO_ticks
                    Label: text = 'DAQmxDO'
                    Field:
                        placeholder = 'DAQmxDO channels to plot'
                        text := graph.DO_channels_to_plot
                    LabelBox:
                        text = 'DO ticks'
                        checked := graph.draw_DO_ticks
                    LabelBox:
                        text = 'labels'
                        checked := graph.draw_label_ticks
                    Label: text = 'plot min'
                    Field:
                        placeholder = 'blank for autolimit'
                        text := graph.plotmin_str
                    Label: text = 'plot max'
                    Field:
                        placeholder = 'blank for autolimit'
                        text := graph.plotmax_str
                    Label: text = 'units'
                    FloatField: value := graph.units
                    Label: text = 'AO scale'
                    FloatField: value := graph.AO_scale

enamldef HSDIO_DigitalOutPage(Window):
    attr HSDIO

    title = 'HSDIO'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label: text = 'enable'
                    CheckBox: checked := HSDIO.enable
                StartTrigger: trigger<<HSDIO.startTrigger
                IndexedStack:
                    title='Script Triggers'
                    iterable<<HSDIO.triggers
                    viewType=HSDIOScriptTrigger
                EvalProp: prop<<HSDIO.resourceName
                EvalProp: prop<<HSDIO.clockRate
                EvalProp: prop<<HSDIO.units
                EvalProp: prop<<HSDIO.hardwareAlignmentQuantum
                Form:
                    Label: text = 'number of channels (multiples of 32)'
                    IntField: value := HSDIO.numChannels
                NumpyDOchannels: p8:
                    channels<<HSDIO.channels

enamldef DAQmxDigitalOutPage(Window):
    attr DAQmx

    title = 'DAQmx Digital Pulse Output'
    style_class << 'valid' if experiment.valid else 'invalid'

    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                LabelBox:
                    text = 'enable'
                    checked := DAQmx.enable
                EvalProp: prop<<DAQmx.resourceName
                EvalProp: prop<<DAQmx.clockRate
                EvalProp: prop<<DAQmx.units
                StartTrigger: trigger<<DAQmx.startTrigger
                NumpyDOchannels: channels<<DAQmx.channels

enamldef DDS_profile(Container):
    attr profile

    hug_height='strong'
    hug_width='strong'
    padding=0

    Container:
        padding=0
        hug_height='strong'
        hug_width='strong'
        constraints=[vbox(description,hbox(container1,container2))]
        Form: description:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=profile.description
        Container: container1:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.frequency
            EvalProp:
                prop<<profile.amplitude
            EvalProp:
                prop<<profile.phase
            EvalProp:
                prop<<profile.RAMMode
            EvalProp:
                prop<<profile.ZeroCrossing
            EvalProp:
                prop<<profile.NoDwellHigh
            EvalProp:
                prop<<profile.FunctionOrStatic
        Container: container2:
            hug_height='strong'
            hug_width='strong'
            EvalProp:
                prop<<profile.RAMFunction
            EvalProp:
                prop<<profile.RAMInitialValue
            EvalProp:
                prop<<profile.RAMStepValue
            EvalProp:
                prop<<profile.RAMTimeStep
            EvalProp:
                prop<<profile.RAMNumSteps
            IndexedStack:
                title='RAMStaticArray'
                iterable<<profile.RAMStaticArray
                viewType=RAMStaticPoint

enamldef RAMStaticPoint(StackItem):
    attr item
    Container:
        Form:
            Label:
                text = 'f/phi/A'
            FloatField:
                value := item.fPhiA
            Label:
                text = 'Mag'
            FloatField:
                value := item.Mag

enamldef ItemProp(StackItem):
    attr item

    Container:
        padding=0
        EvalProp:
            prop<<item

enamldef DDS_channel(GroupBox):
    attr channel
    attr index

    title='channel '+str(index)
    constraints=[hbox(vbox(parameters,RAM),profiles)]

    GroupBox: parameters:
        title='channel parameters'
        flat=True
        constraints=[vbox(description,power,refClockRate,fullScaleOutputPower)]
        Form: description:
            Label:
                text='description'
            Field:
                text:=channel.description
        EvalProp: power:
            prop<<channel.power
        EvalProp: refClockRate:
            prop<<channel.refClockRate
            enabled = True
        EvalProp: fullScaleOutputPower:
            prop<<channel.fullScaleOutputPower

    GroupBox: RAM:
        title='RAM defaults'
        flat=True
        EvalProp:
            prop<<channel.RAMenable
        EvalProp:
            prop<<channel.RAMDestType
        EvalProp:
            prop<<channel.RAMDefaultFrequency
        EvalProp:
            prop<<channel.RAMDefaultAmplitude
        EvalProp:
            prop<<channel.RAMDefaultPhase

    GroupBox: profiles:
        title='profiles'
        hug_height='strong'
        hug_width='strong'
        ComboBox: combo:
            items << list(channel.profileDescriptionList)
            index = (0 if (channel.profiles.length>0) else -1) # pick first profile on load
#        Stack: p1:
#            index<<combo.index
#            RefreshableLooper:
#                iterable<<channel.profiles
#                StackItem:
#                    DDS_profile:
#                        profile<<loop_item
        Conditional:
            condition << ((channel.profiles.length>0) and (combo.index >= 0))
            DDS_profile:
                profile << channel.profiles.listProperty[combo.index]

enamldef DDS_box(Form):
    attr box

    Label:
        text='enable'
    CheckBox:
        checked:=box.enable

    Label:
        text='Description'
    Field:
        text:=box.description

    PushButton:
        text='select USB device reference'
        clicked::
            box.deviceReference=combo.selected_item.strip()
    ComboBox: combo:
        items<<list(box.DDS.deviceList)

    Label:
        text='NI USB-8451 device reference'
    Field:
        pass
        text:=box.deviceReference

    Label:
        text='DIO port'
    IntField:
        #maximum = sys.maxint  # this crashes on Windows, but not on OS X
        maximum = 999999
        minimum = 0
        value:=box.DIOport
    Label:
        text='serialClockRate'
    IntField:
        value := box.serialClockRate

    GroupBox:
        hug_height='strong'
        hug_width='strong'
        title='channels'
        RefreshableLooper:
            iterable<<box.channels
            DDS_channel:
                index<<loop_index
                channel<<loop_item

enamldef DDS_Page(Window):
    attr DDS

    title = 'DDS'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    PushButton:
                        text = 'open connection'
                        clicked::
                            DDS.openThread()
                    PushButton:
                        text = 'close connection'
                        clicked::
                            DDS.close()
                    Label: text = 'IP address'
                    Field: text := DDS.IP
                    Label: text = 'TCP port'
                    IntField: value := DDS.port
                    EvalProp:
                        prop << DDS.timeout
                    Label: text = 'enable'
                    CheckBox: checked := DDS.enable
                    LabelBox:
                        text='initialized?'
                        checked<<DDS.isInitialized
                        enabled=False #keep it greyed out.
                    PushButton:
                        text='Get DDS Device List'
                        clicked :: DDS.getDDSDeviceListThread()
                    PushButton:
                        text='Initialize and Load'
                        clicked :: DDS.initializeDDSThread()
                    PushButton:
                        text='Load'
                        clicked :: DDS.loadDDSThread()

                GroupBox:
                    title = 'DDS boxes'
                    HGroup:
                        align_widths = False
                        ComboBox: combo:
                            items<<list(DDS.boxDescriptionList)
                            index = (0 if (DDS.boxes.length>0) else -1) # pick first profile on load
                        PushButton:
                            text='+'
                            constraints=[width==50,height==20]
                            clicked::
                                DDS.boxes.add()
                                DDS.updateBoxDescriptionList()
                                combo.index=len(DDS.boxes)-2 #point to new box
                        PushButton:
                            text='-'
                            constraints = [width==50,height==20]
                            clicked::
                                i = combo.index
                                if i >= 0:
                                    DDS.boxes.pop(i)
                                    DDS.updateBoxDescriptionList()
                                    combo.index = i-1
                    Container:
                        padding = 0
                        Conditional:
                            condition << ((DDS.boxes.length>0) and (combo.index >= 0))
                            DDS_box:
                                box << DDS.boxes.listProperty[combo.index]

                Form:
                    Label: text = 'connected'
                    CheckBox:
                        checked := DDS.connected
                        enabled = False
                    Label: text='DDS error'
                    Label: text<<str(DDS.error)
                    Label: text='DDS log'
                    Label: text<<DDS.log

enamldef RF_gen(StackItem):
    attr item

    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable
            Label:
                text='description'
            Field:
                text:=item.description
            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power

enamldef HP83623A(StackItem):
    attr item

    Container:
        padding=0
        Form:
            Label:
                text='enable'
            CheckBox:
                checked:=item.enable

            Label:
                text='description'
            Field:
                text:=item.description

            Label:
                text='GPIB channel'
            IntField:
                #TODO: make this a combo box, with the ability to get items from LabView
                value:=item.GPIBchannel
        EvalProp:
            prop<<item.frequency
        EvalProp:
            prop<<item.power
        EvalProp:
            prop<<item.RFoutput
        EvalProp:
            prop<<item.externalTrigger

enamldef RFGenPage(Window):
    attr LabView

    title = 'RF Generators'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked :=  LabView.RF_generators.enable
                IndexedStack: i1:
                    title='HP83623A'
                    iterable=LabView.RF_generators.HP83623A_list
                    viewType=HP83623A
                IndexedStack: i2:
                    title='HP8662A'
                    iterable=LabView.RF_generators.HP8662A_list
                    viewType=RF_gen
                IndexedStack: i3:
                    title='HP83712B'
                    iterable=LabView.RF_generators.HP83712B_list
                    viewType=RF_gen

enamldef CameraPage(Window):
    attr camera

    title = 'Hamamatsu Camera'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='strong'
                hug_width='strong'
                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := camera.enable
                EvalProp:
                    prop<<camera.saveAsPNG
                EvalProp:
                    prop<<camera.saveAsASCII
                EvalProp:
                    prop<<camera.forceImagesToU16
                EvalProp:
                    prop<<camera.EMGain
                EvalProp:
                    prop<<camera.analogGain
                EvalProp:
                    prop<<camera.exposureTime
                EvalProp:
                    prop<<camera.scanSpeed
                EvalProp:
                    prop<<camera.lowLightSensitivity
                EvalProp:
                    prop<<camera.externalTriggerMode
                EvalProp:
                    prop<<camera.triggerPolarity
                EvalProp:
                    prop<<camera.externalTriggerSource
                EvalProp:
                    prop<<camera.cooling
                EvalProp:
                    prop<<camera.fan
                EvalProp:
                    prop<<camera.scanMode
                EvalProp:
                    prop<<camera.photoelectronScaling
                EvalProp:
                    prop<<camera.subArrayLeft
                EvalProp:
                    prop<<camera.subArrayTop
                EvalProp:
                    prop<<camera.subArrayWidth
                EvalProp:
                    prop<<camera.subArrayHeight
                EvalProp:
                    prop<<camera.superPixelBinning
                EvalProp:
                    prop<<camera.frameGrabberAcquisitionRegionLeft
                EvalProp:
                    prop<<camera.frameGrabberAcquisitionRegionTop
                EvalProp:
                    prop<<camera.frameGrabberAcquisitionRegionRight
                EvalProp:
                    prop<<camera.frameGrabberAcquisitionRegionBottom
                EvalProp:
                    prop<<camera.numImageBuffers
                EvalProp:
                    prop<<camera.shotsPerMeasurement

enamldef Andors(Window):
    attr andors

    title = 'Andor Cameras'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            LabelBox:
                text = 'enable'
                checked := andors.enable
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        #Label:
                        #    text = 'enable'
                        #CheckBox:
                        #    checked := andors.enable

                IndexedContainer:
                    iterable << andors.motors
                    viewType = Andor

enamldef Andor(Form):
    attr item

    constraints = [width >= 1200, height >= 1300]

    #title = 'Andor Camera'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    MPLCanvas:
                        figure << item.analysis.figure
                        toolbar_visible = True
                HGroup:
                    Label:
                        text = 'ROI offset (H,V)'
                    IntField:
                        value := item.camera.subimage_position[0]
                    IntField:
                        value := item.camera.subimage_position[1]
                    Label:
                        text = 'ROI size (' + ','.join(map(str,item.camera.ccd_size)) +')'
                    IntField:
                        value := item.camera.subimage_size[0]
                    IntField:
                        value := item.camera.subimage_size[1]
                HGroup:
                    LabelBox:
                        text = 'enable'
                        checked := item.camera.enable
                    LabelBox:
                        text = 'draw_fig'
                        checked := item.analysis.draw_fig
                HGroup:
                    IntField:
                        value := item.camera.serial
                    PushButton:
                        text = 'Select Camera'
                        clicked :: item.camera.setCamera()
                    PushButton:
                        text = 'Read camera config'
                        clicked :: item.camera.rundiagnostics()
                    PushButton:
                        text = 'Open Shutter'
                        clicked :: item.camera.SetShutterEx(0, 1, 0, 0, 1)
                    PushButton:
                        text = 'Close Shutter'
                        clicked :: item.camera.SetShutterEx(0, 2, 0, 0, 2)
                    PushButton:
                        text = 'video mode'
                        clicked :: item.camera.setup_video_thread(item.analysis)
                    PushButton:
                        text = 'stop video'
                        clicked :: item.camera.stop_video()
                HGroup:
                    padding = 0
                    Label:
                        text := 'Camera Serial Number: {}'.format(str(item.camera.CurrentHandle))
                    Label:
                        text := 'CCD Temperature (C): {:.4}'.format(item.camera.temperature)
                    Label:
                        text := 'Maximum Pixel Value: {}, Mean Pixel Value: {}'.format(item.analysis.maxPixel,item.analysis.meanPixel)
                HGroup:
                    EvalProp:
                            prop << item.camera.EMCCDGain
                    EvalProp:
                            prop << item.camera.exposureTime
                HGroup:
                    padding = 0
                    Label:
                        text='Trigger mode'
                    Label:
                        text='Acquisition mode'
                    Label:
                        text='Binmode'
                HGroup:
                    padding = 0
                    ComboBox:
                        items = ['External Start', 'External Level/Bulb', 'External', 'Internal']
                        index := item.camera.triggerMode
                    ComboBox:
                        items = ['Single Scan', 'Accumulate', 'Kinetics', 'Fast Kinetics', 'Run Until Abort']
                        index := item.camera.acquisitionMode
                ComboBox:
                        items = ['Bin Mode: 1x1', 'Bin Mode: 2x2', 'Bin Mode: 4x4']
                        index := item.camera.binMode
                HGroup:
                    padding = 0
                    ComboBox:
                        items = ['Advanced EMGain OFF', 'Advanced EMGain ON']
                        index := item.camera.AdvancedEMGain
                    ComboBox:
                        items = ['EM Gain Mode: DAC 0-255', 'EM Gain Mode: DAC 0-4095', 'EM Gain Mode: Linear', 'EM Gain Mode: Real EM Gain']
                        index := item.camera.EMGainMode
                HGroup:
                    EvalProp:
                            prop<<item.camera.shotsPerMeasurement
                    Form:
                        Label:
                            text = 'shot'
                        SpinBox: shot:
                            minimum=0
                            value := item.analysis.shot
                HGroup:
                    EvalProp:
                        prop << item.camera.minPlot
                    EvalProp:
                        prop << item.camera.maxPlot
                LabelBox:
                    text = 'Autoscale'
                    checked := item.camera.autoscale
                LabelBox:
                    text = 'Background Subtraction'
                    checked := item.analysis.bgsub

enamldef BlackflyClient(Window):
    attr blackfly_client

    title = 'Blackfly Camera Client'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            LabelBox:
                text = 'enable'
                checked := blackfly_client.enable

            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

            IndexedContainer:
                iterable << blackfly_client.cameras
                viewType = Blackfly

enamldef Blackfly(Form):
    attr item

    constraints = [width >= 1000, height >= 600]

    #title = 'Andor Camera'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'
                LabelBox:
                    text = 'enable'
                    checked := item.camera.enable

                #HGroup:
                  #  MPLCanvas:
                  #      figure << item.analysis.figure
                  #      toolbar_visible = True
                HGroup:
                    Label:
                        text = 'serialNumber'
                IntField:
                    value := item.camera.serial


enamldef DAQmxAI(Window):
    attr NIDAQmxAI

    title = 'DAQmx Analog Input'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 10
        Form:
            Label:
                text = 'enable'
            CheckBox:
                checked := NIDAQmxAI.enable
            EvalProp:
                prop << NIDAQmxAI.DeviceName
            EvalProp:
                prop << NIDAQmxAI.chanList
            EvalProp:
                prop << NIDAQmxAI.sample_rate
            EvalProp:
                prop << NIDAQmxAI.samples_per_measurement
            EvalProp:
                prop << NIDAQmxAI.waitForStartTrigger
            EvalProp:
                prop << NIDAQmxAI.triggerSource
            EvalProp:
                prop << NIDAQmxAI.triggerEdge
            Label:
                text << NIDAQmxAI.outputstring
            Form:
                Label:
                    text = 'Apply formula to values'
                CheckBox:
                    checked := NIDAQmxAI.applyFormula
            MultilineField: field:
                text := NIDAQmxAI.formula

enamldef NewportStage(Window):
    attr newportstage

    title = 'Newport Translation Stage'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
        Label:
            text = 'enable'
        CheckBox:
            checked := newportstage.enable
        EvalProp:
            prop << newportstage.comport
        PushButton: Move:
            text = 'Move Now'
            clicked :: newportstage.moveStage()
        EvalProp:
                        prop << newportstage.setposition
        Label:
                        text << 'Current position: {} mm'.format(newportstage.mypos)


enamldef NIScopes(Window):
    attr niscopes

    title = 'National Instruments Scopes'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'

                    IndexedContainer:
                        iterable << niscopes.motors
                        viewType = NIScope



enamldef NIScope(Form):
    attr item

    constraints = [width >= 1500, height >= 1500]
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                constraints = [
                    vbox(Fig,DeviceSettings,Trigger,Horizontal,Channels,Measurements),
                    Fig.width <= 1000,
                    DeviceSettings.width == Fig.width,
                    Trigger.width == Fig.width,
                    Horizontal.width == Fig.width,
                    Channels.width == Fig.width,
                    Measurements.width == Fig.width
                ]
                style_class << 'valid' if experiment.valid else 'invalid'
                MPLCanvas: Fig:
                    figure << item.analysis.figure
                    toolbar_visible = False
                GroupBox: DeviceSettings:
                    title = "Device"
                    EvalProp:
                        prop << item.scope.DeviceName
                    LabelBox:
                        text = 'enable'
                        checked := item.scope.enable
                GroupBox: Trigger:
                    title << "Trigger"
                    #HGroup:
                    #constraints = [
                    #    contents_left == TSlope.left,
                    #    TMode.left == TSlope.right+10,
                    #    TSource.left == TMode.right+10,
                    #    TLevel.left == TSource.right+10,
                    #    TDelay.left == TLevel.right+10,
                    #    TDelay.right == contents_right
                    #]
                    ComboBox: TSlope:
                        items = ['Rising Edge', 'Falling Edge']
                        index := item.scope.TrigSlope
                    #ComboBox: TMode:
                    #    items = ['Normal', 'Auto', 'Single']
                    #    index := item.scope.TrigMode
                    ComboBox: TSource:
                        items = ['CH0', 'CH1', 'Ext', 'Immediate']
                        index := item.scope.TrigSource
                    EvalProp: TLevel:
                        prop << item.scope.TrigLevel
                    EvalProp: TDelay:
                        prop << item.scope.TrigDelay
                GroupBox: Horizontal:
                    title << "Horizontal Axis"
                    HGroup:
                        ComboBox:
                            items = ['0.33 s', '0.20 s', '0.10 s', '50.0 ms', '20.0 ms', '10.0 ms', '5.0 ms', '2.0 ms', '1.0 ms', '0.50 ms', '0.20 ms', '0.10 ms', '50 us', '20 us', '10 us', '*5.0 us', '*2.0 us', '*1.0 us', '*0.50 us', '*0.25 us']
                            index := item.scope.HorizScale
                        EvalProp:
                            prop << item.scope.HorizRecordLength
                HGroup: Channels:
                    constraints = [
                        hbox(CH0, CH1),
                        CH0.width == 490,
                        CH1.width == CH0.width,
                    ]
                    GroupBox: CH0:
                        title << "Channel 0"
                        ComboBox:
                            items = ['2.5 V', '2.0 V', '1.0 V', '0.50 V', '0.20 V', '0.10 V']
                            index := item.scope.Chan0VertScale
                        ComboBox:
                            items = ['DC', 'AC', 'Ground']
                            index := item.scope.Chan0Coupling
                        ComboBox:
                            items = ['1 MOhm', '*50 Ohm']
                            index := item.scope.Chan0Impedance
                        ComboBox:
                            items = ['1:1', '10:1']
                            index := item.scope.Chan0Atten
                        EvalProp:
                            prop << item.scope.Chan0Offset
                    GroupBox: CH1:
                        title << "Channel 1"
                        ComboBox:
                            items = ['2.5 V', '2.0 V', '1.0 V', '0.50 V', '0.20 V', '0.10 V']
                            index := item.scope.Chan1VertScale
                        ComboBox:
                            items = ['DC', 'AC', 'Ground']
                            index := item.scope.Chan1Coupling
                        ComboBox:
                            items = ['1 MOhm', '*50 Ohm']
                            index := item.scope.Chan1Impedance
                        ComboBox:
                            items = ['1:1', '10:1']
                            index := item.scope.Chan1Atten
                        EvalProp:
                            prop << item.scope.Chan1Offset
                GroupBox: Measurements:
                    HGroup:
                        Label:
                            text := 'CH0 Maximum: {}, CH0 Mean: {}'.format(item.analysis.maxPixel0,item.analysis.meanPixel0)
                    HGroup:
                        Label:
                            text := 'CH1 Maximum: {}, CH1 Mean: {}'.format(item.analysis.maxPixel1,item.analysis.meanPixel1)



enamldef PICams(Window):
    attr picams

    title = 'Princeton Instruments Cameras'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'

                    IndexedContainer:
                        iterable << picams.motors
                        viewType = Picam

enamldef Picam(Form):
    attr item

    constraints = [width >= 1000, height >= 1500]

    #title = 'Princeton Instruments Camera'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    MPLCanvas:
                        figure << item.analysis.figure
                        toolbar_visible = True
                    Slider:
                        orientation = 'vertical'
                        tracking = False
                        value := item.camera.roilowv
                        value :: item.camera.setROIvalues()
                        minimum << item.camera.roimaxv
                        visible << item.camera.enableROI
                        maximum = 0
                    Slider:
                        orientation = 'vertical'
                        tracking = False
                        value := item.camera.roihighv
                        value :: item.camera.setROIvalues()
                        minimum << item.camera.roimaxv
                        visible << item.camera.enableROI
                        maximum = 0
                Slider:
                    tracking = False
                    value := item.camera.roilowh
                    value :: item.camera.setROIvalues()
                    minimum = 0
                    maximum << item.camera.roimaxh
                    visible << item.camera.enableROI
                Slider:
                    tracking = False
                    value := item.camera.roihighh
                    value :: item.camera.setROIvalues()
                    minimum = 0
                    maximum << item.camera.roimaxh
                    visible << item.camera.enableROI
                HGroup:
                    PushButton:
                        text = 'video mode'
                        clicked :: item.camera.setup_video_thread(item.analysis)
                    PushButton:
                        text = 'stop video'
                        clicked :: item.camera.stop_video()
                HGroup:
                    EvalProp:
                        prop << item.camera.currentCamera
                    PushButton:
                        text = 'Select Camera'
                        clicked :: item.camera.setCamera()
                HGroup:
                    padding = 0
                    Label:
                        text := 'Camera Serial Number: {}'.format(str(item.camera.currentSerial))
                    Label:
                        text := 'CCD Temperature (C): {:.4}'.format(item.camera.currentTemp)
                    Label:
                        text := 'Maximum Pixel Value: {}, Mean Pixel Value: {}'.format(item.analysis.maxPixel,item.analysis.meanPixel)
                LabelBox:
                    text = 'enable'
                    checked := item.camera.enable
                EvalProp:
                    prop << item.camera.AdcEMGain
                ComboBox:
                    items = ['Low Analog Gain', 'Medium Analog Gain', 'High Analog Gain']
                    index := item.camera.AdcAnalogGain
                EvalProp:
                    prop << item.camera.exposureTime
                HGroup:
                    padding = 0
                    ComboBox:
                        items = ['Rising Edge', 'Falling Edge', 'Level', 'Auto']
                        index := item.camera.triggerMode
                    ComboBox:
                        items = ['Shutter Normal', 'Shutter Always Closed', 'Shutter Always Open', 'Shutter Open Before Trigger']
                        index := item.camera.shutterMode
                    ComboBox:
                        items = ['Bin Mode: 1x1', 'Bin Mode: 2x2', 'Bin Mode: 4x4']
                        index := item.camera.binMode
                    ComboBox:
                        items = ['Readout Control: Dual Imaging', 'Readout Control: Frame Transfer', 'Readout Control: Full Frame', 'Readout Control: Kinetics', 'Readout Control: Spectra Kinetics']
                        index := item.camera.ReadoutControl
                #HGroup:
                    #padding = 0
                    #ComboBox:
                    #    items = ['EM Gain Mode: DAC 0-255', 'EM Gain #Mode: DAC 0-4095', 'EM Gain Mode: Linear', 'EM Gain #Mode: Real EM Gain']
                    #    index := item.camera.EMGainMode
                EvalProp:
                    prop<<item.camera.shotsPerMeasurement
                LabelBox:
                    text = 'Sum Measurements'
                    checked := item.camera.averageMeasurements
                LabelBox:
                    text = 'Display Image'
                    checked := item.analysis.draw_fig
                Form:
                    Label:
                        text = 'shot'
                    SpinBox: shot:
                        minimum=0
                        value := item.analysis.shot
                Container:
                    LabelBox:
                        text = 'Autoscale'
                        checked := item.camera.autoscale
                    LabelBox:
                        text = 'Background Subtraction'
                        checked := item.analysis.bgsub
                    EvalProp:
                        prop << item.camera.minPlot
                    EvalProp:
                        prop << item.camera.maxPlot
                LabelBox:
                    text = 'Use Demo Camera'
                    checked := item.camera.useDemo
                PushButton:
                    text = 'Print Parameters'
                    clicked :: item.camera.PrintParameters()




enamldef FiltersPage(Page):
    title = 'Filters'

enamldef AOequation(StackItem):
    attr item
    Container:
        hug_height='strong'
        hug_width='strong'
        GroupBox:
            flat=True
            title='description'
            Field:
                constraints=[width==500]
                text:=item.description
                placeholder='description'
        GroupBox:
            flat=True
            title='function'
            Field:
                constraints=[width==500]
                text:=item.function
                placeholder='function that evaluates to a 1D array, where t will be replaced with AO.timesteps'

enamldef AnalogOutput(Window):
    attr AO

    title = 'Analog Output'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                LabelBox: e1:
                    text='enable'
                    checked:=AO.enable
                EvalProp: e2:
                    prop<<AO.physicalChannels
                Form:
                    Label: text = 'number of channels'
                    IntField: value := AO.numChannels
                    Label: text = 'channel descriptions'
                    Field: text := AO.channel_descriptions
                EvalProp: e3:
                    prop<<AO.minimum
                EvalProp: e4:
                    prop<<AO.maximum
                EvalProp: e5:
                    prop<<AO.clockRate
                EvalProp: e6:
                    prop<<AO.units
                EvalProp: e8:
                    prop<<AO.waitForStartTrigger
                EvalProp: e9:
                    prop<<AO.triggerSource
                EvalProp: e10:
                    prop<<AO.triggerEdge
                EvalProp: e11:
                    prop<<AO.exportStartTrigger
                EvalProp: e12:
                    prop<<AO.exportStartTriggerDestination
                EvalProp: e13:
                    prop<<AO.useExternalClock
                EvalProp: e14:
                    prop<<AO.externalClockSource
                EvalProp: e15:
                    prop<<AO.maxExternalClockRate

enamldef AnalogInput(Window):
    attr AI
    attr filters
    attr analysis

    title = 'Analog Input'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='strong'
                hug_width='strong'
                LabelBox:
                    text='enable'
                    checked := AI.enable
                EvalProp:
                    prop << AI.sample_rate
                EvalProp:
                    prop << AI.source
                EvalProp:
                    prop << AI.samples_per_measurement
                EvalProp:
                    prop << AI.waitForStartTrigger
                EvalProp:
                    prop << AI.triggerSource
                EvalProp:
                    prop << AI.triggerEdge
                NumpyAOchannels:
                    channels<<AI.channels

                # filter
                GroupBox:
                    title = 'Analog Input Filter'
                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := filters.enable

                    Label:
                        text = 'What to filter: a string representing a list of [(channel,samples_list,low,high), ...]\nSamples in samples_list will be averaged.'
                    Field:
                        text := filters.what_to_filter

                    Label:
                        text = 'filter level'
                    ComboBox:
                        items = ['None: increment measurement total',
                                     'soft: continue with other analyses, but do not increment measurement total',
                                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
                        index := filters.filter_level

                        Label:
                            text = 'Status'
                        Label:
                            text := filters.text

                # cumulative plot of noise eater data
                GroupBox:
                    title = 'Analog Input plots'
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := analysis.enable
                        Label:
                            text = 'draw fig'
                        CheckBox:
                            checked := analysis.draw_fig
                        Label:
                            text = 'specify what to graph with a list of tuples: [(channel,samples_list),(channel, samples_list)...]\nSamples in samples_list will be averaged.'
                        Field:
                            text := analysis.list_of_what_to_plot
                        PushButton:
                            text = 'clear'
                            clicked :: analysis.clear()
                MPLCanvas: canvas:
                    constraints=[(height==500)|'strong']
                    hug_width='ignore'
                    figure << analysis.figure


enamldef Counters(Window):
    attr counters

    title = 'Counters'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='strong'
                hug_width='strong'

                LabelBox:
                    text='enable'
                    checked := counters.enable
                IndexedContainer:
                    dynamic = True
                    iterable << counters.counters
                    viewType = Counter


enamldef Counter(Form):
    attr item

    Label: text = 'counter source'
    Field: text := item.counter_source
    Label: text = 'clock source'
    Field: text := item.clock_source
    Label: text = 'clock rate (used for internal source only) [Hz]'
    FloatField: value := item.clock_rate

enamldef DCNoiseEaterChannel(Container):
    attr item

    Form:
        Label:
            text = 'Set: Allow settings on computer to overwrite those on noise eater'
        CheckBox:
            checked := item.update
        Label:
            text = 'Get: Allow settings on noise eater to overwrite those on computer'
        CheckBox:
            checked := item.allow_get

        # variables from DC noise eater
        # read/write variables
        Label:
            text = 'mode'
        ComboBox:
            items = ['off', 'run', 'idle-hi', 'idle-med', 'idle-lo', 'ramp']
            index := item.mode
        Label:
            text = 'trigger warning?'
        CheckBox:
            checked := item.warnSetting
        Label:
            text = 'limit range'
        IntField:
            value := item.limitRange
        Label:
            text = 'invert'
        CheckBox:
            checked := item.invert
        Label:
            text = 'integration time'
        IntField:
            value := item.integrationTime
        Label:
            text = 'trigger number'
        SpinBox:
            minimum = 0
            maximum = 3
            value := item.trigNum
        Label:
            text = 'measurements to average'
        IntField:
            value := item.measNum
        Label:
            text = 'Kp'
        EvalProp:
            prop << item.kp
        Label:
            text = 'Ki'
        EvalProp:
            prop << item.ki
        Label:
            text = 'setpoint'
        IntField:
            value := item.setpoint

        # read only
        Label:
            text = 'average'
        IntField:
            value << item.average
            enabled = False
        Label:
            text = 'error'
        IntField:
            value << item.error
            enabled = False
        Label:
            text = 'V in'
        IntField:
            value << item.vin
            enabled = False
        Label:
            text = 'V out'
        IntField:
            value << item.vout
            enabled = False
        Label:
            text = 'warning'
        CheckBox:
            checked << item.warning
            enabled = False

enamldef DCNoiseEater(Container):
    # represents an individual noise eater box
    attr item

    hug_height='strong'
    hug_width='strong'
    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := item.enable
        Label:
            text = 'COM port'
        Field:
            text := item.comport

    IndexedContainer:
        dynamic = False
        iterable << item.channels
        viewType = DCNoiseEaterChannel

enamldef DCNoiseEaters(Window):
    # creates an indexed display of the noise eater list
    attr DC_noise_eaters
    attr analysis
    attr filters

    title = 'DC Noise Eaters'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    LabelBox:
                        text = 'enable'
                        checked := DC_noise_eaters.enable

                    IndexedContainer:
                        iterable << DC_noise_eaters.boxes
                        viewType = DCNoiseEater

                # filter
                GroupBox:
                    title = 'DC Noise Eater Filter'
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := filters.enable

                        Label:
                            text = 'What to filter: a string representing a list of [(box,channel,variable,low,high), ...]'
                        Field:
                            text := filters.what_to_filter

                        Label:
                            text = 'filter level'
                        ComboBox:
                            items = ['None: increment measurement total',
                                     'soft: continue with other analyses, but do not increment measurement total',
                                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
                            index := filters.filter_level

                        Label:
                            text = 'Status'
                        Label:
                            text := filters.text

                # cumulative plot of noise eater data
                GroupBox:
                    title = 'DC Noise Eater plots'
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := analysis.enable
                        Label:
                            text = 'draw_fig'
                        CheckBox:
                            checked := analysis.draw_fig
                        Label:
                            text = 'specify box, channel and variable (see indices below) to graph with a list of tuples: [(box,channel,variable),(box,channel,variable)]\n 0:mode, 1:warnSetting, 2:limitRange, 3:invert, 4:integrationTime, 5:trigNum, 6:measNum, 7:kp, 8:ki, 9:setpoint, 10:average, 11:error, 12:vin, 13:vout, 14:warning'
                        Field:
                            text := analysis.list_of_what_to_plot
                    PushButton:
                        text = 'clear'
                        clicked :: analysis.clear()
                    MPLCanvas: canvas:
                        constraints=[(height==500)|'strong']
                        hug_width='ignore'
                        figure << analysis.figure

enamldef Arroyo(Window):
    attr experiment
    style_class << 'valid' if experiment.valid else 'invalid'

    title = 'Arroyo'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height = 'strong'
                hug_width = 'strong'

enamldef PiezoChannel(Container):
    attr channel

    hug_height = 'strong'
    hug_width = 'strong'
    constraints=[hbox(description, setServo,setPosition,label)]
    Field: description:
        placeholder='description'
        text:=channel.description
    EvalProp: setServo:
        prop<<channel.setServo
    EvalProp: setPosition:
        prop<<channel.setPosition
    GroupBox: label:
        flat=True
        title='read from piezo'
        Label:
            text<<'axis:{}\tservo:{}\tposition:'.format(channel.readAxis,channel.readServo,channel.readPosition)

enamldef PiezoController(StackItem):
    attr item

    Container:
        hug_height = 'strong'
        hug_width = 'strong'
        Form:
            Label:
                text='description'
            Field:
                placeholder='description'
                text:=item.description
            Label:
                text='enable'
            CheckBox:
                checked::item.enable
            Label:
                text='serial number set:'
            Field:
                placeholder='serial number'
                text:=item.serialNumber
            Label:
                text='id:'
            Label:
                text:=item.identificationRead
            Label:
                text='serial number read:'
            Label:
                text:=item.serialNumberRead
        RefreshableLooper:
            iterable<<item.channels
            PiezoChannel:
                channel<<loop_item

enamldef PI_Piezo(Window):
    attr piezo
    style_class << 'valid' if experiment.valid else 'invalid'

    title = 'PI_Piezo'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                LabelBox:
                    text='enable'
                    checked:=piezo.enable
                IndexedStack:
                    title='Piezo Controllers'
                    iterable<<piezo.controllers
                    viewType=PiezoController

enamldef AnalysisImage(Container):
    attr analysis

    padding=0
    constraints=[(height==550)|'strong',(width==550)|'strong']
    MPLCanvas:
        constraints=[(height==550)|'strong',(width==550)|'strong']
        figure<<analysis.figure

enamldef MultiImage(Window):
    attr experiment
    attr analysis0
    attr analysis2
    attr analysis3

    title = 'Live Images'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Label:
                    text<<analysis3.text

                HGroup:
                    padding = 0
                    spacing = 0
                    align_widths = True

                    Container:
                        MPLCanvas:
                            constraints = [(height==1000)|'strong']
                            figure << analysis0.figure
                        Form:
                            Label:
                                text = 'draw_fig'
                            CheckBox:
                                checked := analysis0.draw_fig
                            Label:
                                text = 'Show ROIs?'
                            CheckBox:
                                checked := analysis0.showROIs
                            Label:
                                text = 'shot'
                            SpinBox:
                                minimum = 0
                                value := analysis0.shot
                            Label:
                                text = 'subtract background (visual only, does not change data)'
                            CheckBox:
                                checked := analysis0.subtract_background

                    Container:
                        MPLCanvas:
                            constraints = [(height==1000)|'strong']
                            figure << analysis2.figure
                        Form:
                            Label:
                                text = 'enable'
                            CheckBox:
                                checked := analysis2.enable
                            Label:
                                text = 'draw_fig'
                            CheckBox:
                                checked := analysis2.draw_fig
                            Label:
                                text='Show ROIs?'
                            CheckBox:
                                checked:=analysis2.showROIs
                            Label:
                                text = 'shot'
                            SpinBox:
                                minimum=0
                                value := analysis2.shot
                            Label:
                                text = 'plot ymin'
                            Field:
                                placeholder='blank for autolimit'
                                text := analysis2.min_str
                            Label:
                                text = 'plot ymax'
                            Field:
                                placeholder='blank for autolimit'
                                text := analysis2.max_str
                            Label:
                                text = 'subtract background (visual only, does not change data)'
                            CheckBox:
                                checked := analysis2.subtract_background
                            PushButton:
                                text = 'use this image as background'
                                clicked :: analysis2.set_background()

enamldef ImageBrowser(Window):
    attr experiment
    attr analysis1

    title = 'Past Image Browser'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                MPLCanvas:
                    constraints = [(height==1000)|'strong']
                    figure << analysis1.figure
                Form:
                    Label:
                       text='Show ROIs?'
                    CheckBox:
                        checked:=analysis1.showROIs
                GroupBox:
                    hug_height='strong'
                    hug_width='strong'
                    Looper:
                        iterable << experiment.independentVariables  # analysis1.ivarNames
                        Form:
                            Label:
                                text<<loop_item.name
                            ComboBox:
                                items<<[str(i) for i in loop_item.valueList]  # analysis1.ivarValueLists[loop_index]]
                                index::
                                    analysis1.setIteration(loop_index, index) #send which ivar (loop_index) to update to index
                    Form:
                        Label:
                            text='Measurement'
                        SpinBox:
                            minimum=0
                            maximum=9999999 #a big number
                            value:=analysis1.measurement
                    Form:
                        Label:
                            text='Shot'
                        SpinBox:
                            minimum=0
                            maximum=9999999 #a big number
                            value:=analysis1.shot

enamldef SquareROI(Container):
    attr item
    attr num
    hug_height='strong'
    hug_width='strong'
    constraints=[hbox(l0,f0,f1,f2,f3)]
    Label: l0:
        constraints = [(width==50)|'strong']
        text=str(num)
    MyIntField: f0:
        constraints = [(width==50)|'strong']
        placeholder='left'
        value:=item['left']
    MyIntField: f1:
        constraints = [(width==50)|'strong']
        placeholder='top'
        value:=item['top']
    MyIntField: f2:
        constraints = [(width==50)|'strong']
        placeholder='right'
        value:=item['right']
    MyIntField: f3:
        constraints = [(width==50)|'strong']
        placeholder='bottom'
        value:=item['bottom']

enamldef SquareROIContainer(Window):
    attr experiment
    attr analysis

    title = 'Square ROIs'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='ignore'
                hug_width='ignore'
                constraints=[hbox(dynoCont,canvas),align('top',dynoCont,canvas)]
                Container: dynoCont:
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := analysis.enable
                        Label:
                            text = 'draw_fig'
                        CheckBox:
                            checked := analysis.draw_fig
                    Container:
                        hug_height='strong'
                        hug_width='strong'
                        constraints=[hbox(l0,l1,l2,l3,l4)]
                        Label: l0:
                            constraints = [(width==50)|'strong']
                            text = 'ROI#'
                        Label: l1:
                            constraints = [(width==50)|'strong']
                            text = 'left'
                        Label: l2:
                            constraints = [(width==50)|'strong']
                            text = 'top'
                        Label: l3:
                            constraints = [(width==50)|'strong']
                            text = 'right'
                        Label: l4:
                            constraints = [(width==50)|'strong']
                            text = 'bottom'
                    Include: dyno:
                        objects<<[SquareROI(item=x,num=i) for i,x in enumerate(analysis.ROIs)]
                    Container:
                        hug_height='strong'
                        hug_width='strong'
                        constraints=[hbox(l5,l1,l2,l3,l4)]
                        Label: l5:
                            constraints = [(width==50)|'strong']
                            text = 'BG ROI#'
                    Include: dyno1:
                        objects<<[SquareROI(item=x,num=i) for i,x in enumerate(analysis.ROIs_bg)]
                MPLCanvas: canvas:
                    constraints=[(height==512)|'strong',(width==512)|'strong']
                    hug_width='ignore'
                    figure<<analysis.figure

enamldef ThresholdROI(Container):
    attr item
    attr num
    hug_height='strong'
    hug_width='strong'
    constraints=[hbox(l0,f0,f1)]
    Label: l0:
        constraints = [(width==50)|'strong']
        text=str(num)
    MyIntField: f0:
        constraints = [(width==50)|'strong']
        placeholder='1'
        value := item[0]['1']
    MyIntField: f1:
        constraints = [(width==50)|'strong']
        placeholder='1'
        value := item[1]['1']

enamldef ThresholdROIContainer(Window):
    attr experiment
    attr analysis

    title = 'Threshold ROIs'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                hug_height='ignore'
                hug_width='ignore'
                constraints=[hbox(dynoCont,canvas),align('top',dynoCont,canvas)]
                Container: dynoCont:
                    Form:
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := analysis.enable
                        Label:
                            text = 'draw_fig'
                        CheckBox:
                            checked := analysis.draw_fig
                    Container:
                        hug_height='strong'
                        hug_width='strong'
                        constraints=[hbox(l0,l1,l2)]
                        Label: l0:
                            constraints = [(width==50)|'strong']
                            text = 'ROI#'
                        Label: l1:
                            constraints = [(width==50)|'strong']
                            text = 's0 threshold'
                        Label: l2:
                            constraints = [(width==50)|'strong']
                            text = 's1 threshold'
                    Include: dyno:
                        objects<<[ThresholdROI(item=x,num=i) for i,x in enumerate(numpy.transpose(analysis.threshold_array))]
                MPLCanvas: canvas:
                    constraints=[(height==512)|'strong',(width==512)|'strong']
                    hug_width='ignore'
                    figure<<analysis.figure


enamldef GaussianROI(Window):
    attr analysis

    title = 'Gaussian ROIs'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig
                    Label:
                        text = 'perform gaussian grid fit'
                    CheckBox:
                        checked := analysis.enable_grid_fit
                    Label:
                        text = 'automatically use ROIs from valid fits'
                    CheckBox:
                        checked := analysis.automatically_use_rois
                    Label:
                        text = 'calculate gaussian ROI sums'
                    CheckBox:
                        checked := analysis.enable_calculate_sums
                    Label:
                        text = 'shot'
                    SpinBox:
                        value := analysis.shot
                    Label:
                        text = 'subtract background?'
                    CheckBox:
                        checked := analysis.subtract_background
                    Label:
                        text = 'subtract background from sums?'
                    CheckBox:
                        checked := analysis.subtract_background_from_sums
                    Label:
                        text = 'multiply sums by photoelectron scaling?'
                    CheckBox:
                        checked :=analysis.multiply_sums_by_photoelectron_scaling
                    Label:
                        text = 'clean up image with ICA?'
                    CheckBox:
                        checked := analysis.useICA
                    PushButton:
                        text = "use these ROIs"
                        clicked :: analysis.use_current_rois()
                HGroup:
                    align_widths = False
                    Label:
                        text = 'initial guess'
                    Label:
                        text = 'top'
                    FloatField:
                        value := analysis.top
                    Label:
                        text = 'left'
                    FloatField:
                        value := analysis.left
                    Label:
                        text = 'bottom'
                    FloatField:
                        value := analysis.bottom
                    Label:
                        text = 'right'
                    FloatField:
                        value := analysis.right
                MPLCanvas:
                    figure<<analysis.figure

enamldef LoadingFilters(GroupBox):
    attr filters
    title = 'Region of Interest Sum (Loading) Filters'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := filters.enable

        Label:
            text = 'A boolean expression that evaluates the filter.\nUse t[shot,region] for the summation over any shot and region.\nFor example to require that sites 15 and 17 load: t[0,17] and t[0,15]'
        Field:
            text := filters.filter_expression
            style_class << 'valid' if filters.valid else 'invalid'

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

        Label:
            text = 'Status'
        Label:
            text := filters.text

enamldef FirstMeasurementsFilter(GroupBox):
    attr filters
    title = 'Drop First N Measurements Filter'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := filters.enable

        Label:
            text = 'How many measurements should we drop at the beginning of each iteration?'
        SpinBox:
            minimum = 0
            value := filters.N

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

enamldef Histogram(Window):
    attr experiment
    attr analysis

    title = 'Histogram'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig
                    Label:
                        text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
                    Field:
                        text := analysis.list_of_what_to_plot
                MPLCanvas:
                    figure<<analysis.figure

enamldef HistogramGrid(Window):
    attr experiment
    attr analysis

    title = 'Histogram Grid'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig
                    Label:
                        text = 'shot to display'
                    SpinBox:
                        value := analysis.shot
                    Label:
                        text = 'calculate new cutoffs'
                    CheckBox:
                        checked := analysis.calculate_new_cutoffs
                    Label:
                        text = 'automatically use new cutoffs'
                    CheckBox:
                        checked := analysis.automatically_use_cutoffs
                    Label:
                        text = 'cutoff shot mapping list: [shot 0, shot 1, ...] (i.e. [1, 1] to always use shot 1 cutoffs)'
                    Field:
                        text := analysis.cutoff_shot_mapping
                    PushButton:
                        text = 'use new cutoffs'
                        clicked ::
                            analysis.use_cutoffs()
                MPLCanvas:
                    figure<<analysis.figure

enamldef MeasurementsGraph(Window):
    attr experiment
    attr analysis

    title = 'Measurements Graph'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig
                    Label:
                        text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
                    Field:
                        text := analysis.list_of_what_to_plot
                    PushButton:
                        text = 'clear'
                        clicked :: analysis.clear()
                MPLCanvas:
                    figure << analysis.figure

enamldef IterationsGraph(Window):
    attr experiment
    attr analysis

    title = 'Iterations Graphs'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'specify shots and regions to graph with a list of pairs: [(shot,region),(shot,region)]'
                    Field:
                        text := analysis.list_of_what_to_plot
                    Label:
                        text = 'update every measurement? (if not, only update at end of iteration)'
                    CheckBox:
                        checked := analysis.update_every_measurement
                        enabled = False
                HGroup:
                    align_widths = False
                    Label: l5:
                        text = 'enable'
                    CheckBox: cb5:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig
                    Label: l0:
                        text = 'draw connecting lines'
                    CheckBox: cb0:
                        checked := analysis.draw_connecting_lines
                    Label: l1:
                        text = 'draw error bars (1 sigma std dev of mean)'
                    CheckBox: cb1:
                        checked := analysis.draw_error_bars
                    Label: l2:
                        text = 'only add data that has passed loading filter'
                    CheckBox: cb2:
                        checked := analysis.add_only_filtered_data
                    Label: l3:
                        text = 'plot ymin'
                    Field: f3:
                        placeholder='blank for autolimit'
                        text := analysis.ymin
                    Label: l4:
                        text = 'plot ymax'
                    Field: f4:
                        placeholder='blank for autolimit'
                        text := analysis.ymax
                MPLCanvas:
                    figure<<analysis.figure

enamldef RetentionGraph(Window):
    attr experiment
    attr analysis

    title = 'Retention Graph'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'specify regions to graph with a list: [region1, region2]'
                    Field:
                        text := analysis.list_of_what_to_plot
                HGroup:
                    align_widths = False
                    Label: l5:
                        text = 'enable'
                    CheckBox: cb5:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig
                    Label: l0:
                        text = 'draw connecting lines'
                    CheckBox: cb0:
                        checked := analysis.draw_connecting_lines
                    Label: l1:
                        text = 'draw error bars (1 sigma binomial std dev of mean using normal approximation)'
                    CheckBox: cb1:
                        checked := analysis.draw_error_bars
                    Label: l2:
                        text = 'only add data that has passed loading filter'
                    CheckBox: cb2:
                        checked := analysis.add_only_filtered_data
                    Label: l3:
                        text = 'plot ymin'
                    Field: f3:
                        placeholder='blank for autolimit'
                        text := analysis.ymin
                    Label: l4:
                        text = 'plot ymax'
                    Field: f4:
                        placeholder='blank for autolimit'
                        text := analysis.ymax
                MPLCanvas:
                    figure<<analysis.figure


enamldef CounterGraph(Window):
    attr analysis

    title = 'Counter Graph'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig
                    Label:
                        text = 'pre-Data Bins'
                    IntField:
                        value := analysis.drops
                    Label:
                        text = 'Data Bins'
                    IntField:
                        value := analysis.bins

                MPLCanvas:
                    figure<<analysis.figure


enamldef CounterHistAnalysis(Window):
    attr analysis

    title = 'Counter Histogram Analysis'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig

                    Label:
                        text = 'Data Bins'
                    IntField:
                        value := analysis.hbins

                MPLCanvas:
                    figure<<analysis.figure


enamldef Ramsey(Window):
    attr analysis

    title = 'Ramsey analysis'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                HGroup:
                    align_widths = False
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig
                    Label:
                        text = 'draw error bars (1 sigma binomial std dev of mean using normal approximation)'
                    CheckBox:
                        checked := analysis.draw_error_bars
                    Label:
                        text = 'roi'
                    SpinBox:
                        value := analysis.roi
                    Label:
                        text = 'time variable name'
                    Field:
                        text := analysis.time_variable_name
                GroupBox:
                    title = 'fit'
                    constraints=[grid([z0,z1,z2],[a0,a1,a2],[b0,b1,b2],[c0,c1,c2],[d0,d1,d2])]
                    Label: z0:
                        text = 'variable'
                    Label: z1:
                        text = 'guess'
                    Label: z2:
                        text = 'fit'
                    Label: a0:
                        text = 'amplitude'
                    FloatField: a1:
                        value := analysis.amplitude_guess
                    FloatField: a2:
                        value := analysis.amplitude
                        read_only = True
                    Label: b0:
                        text = 'frequency'
                    FloatField: b1:
                        value := analysis.frequency_guess
                    FloatField: b2:
                        value := analysis.frequency
                        read_only = True
                    Label: c0:
                        text = 'offset'
                    FloatField: c1:
                        value := analysis.offset_guess
                    FloatField: c2:
                        value := analysis.offset
                        read_only = True
                    Label: d0:
                        text = 'decay'
                    FloatField: d1:
                        value := analysis.decay_guess
                    FloatField: d2:
                        value := analysis.decay
                        read_only = True
                MPLCanvas:
                    figure<<analysis.figure

enamldef TTL_filters(GroupBox):
    attr instrument
    attr filters
    title = 'TTL (Laser Lock Monitor) Filters'

    Form:
        Label:
            text = 'enable'
        CheckBox:
            checked := instrument.enable

        Label:
            text = 'lines'
        Field:
            text := instrument.lines

        Label:
            text = 'filter level'
        ComboBox:
            items = ['None: increment measurement total',
                     'soft: continue with other analyses, but do not increment measurement total',
                     'med: continue with other analyses, do not increment measurement total, and delete measurement data after all analyses',
                     'hard: do not continue with other analyses, do not increment measurement total, delete measurement data']
            index := filters.filter_level

        Label:
            text = 'Status'
        Label:
            text := filters.text

def get_num_optimization_variables(experiment):
    try:
        return len(experiment.optimizer.optimization_variables)
    except:
        return 0

enamldef Optimizer(Window):
    attr experiment
    attr analysis

    title = 'Optimizer'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable override (to optimize, enable here and on independent variables'
                    CheckBox:
                        checked := analysis.enable_override

                    Label:
                        text = 'enabled?'
                    CheckBox:
                        checked << analysis.enable_gui
                        enabled = False
                    Label:
                        text = 'draw_fig'
                    CheckBox:
                        checked := analysis.draw_fig

                    Label:
                        text='update method'
                    ComboBox:
                        items = ['Nelder-Mead', 'genetic', 'gradient descent', 'weighted Nelder-Mead', 'smart Nelder-Mead']
                        index := analysis.optimization_method

                    # For the gradient method, the initial step size for each variable is used for determining the gradient.
                    # We need a separate step size that multiplies the gradient
                    Conditional:
                        condition << (analysis.optimization_method == 2)
                        Label:
                            text = 'Initial gradient step size (fraction)'
                        FloatField:
                            value := analysis.line_search_initial_step
                        Label:
                            text='End when step size is less than (fraction)'
                        FloatField:
                            value := analysis.end_condition_step

                    Label:
                        text='cost function'
                    MultilineField:
                        #constraints=[height==300]
                        text:=experiment.optimizer.cost_function

                    Label:  text = 'starting cost'
                    Label:  text << analysis.yi0_str

                    Label:  text = 'best cost'
                    Label:  text << analysis.best_yi_str

                    Label:  text = 'current cost'
                    Label:  text << analysis.yi_str

                    Label: text = 'best experiment number'
                    Label: text << analysis.best_experiment_number_str

                MPLCanvas: canvas:
                    constraints << [(height==150*(len(experiment.independentVariables)+1))|'strong'] #,(width==1000)|'strong']
                    figure << analysis.figure


enamldef Instek_PST(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text := 'serial number: {}'.format(item.serial_number)
        EvalProp:
            prop << item.com_port
        EvalProp:
            prop << item.tracking
        Container:
            constraints = [
                vbox(
                    hbox(Ch1V, Ch1A),
                    hbox(Ch2V, Ch2A),
                    hbox(Ch3V, Ch3A)
                )
            ]
            hug_width = 'strong'
            hug_height = 'strong'
            EvalProp: Ch1V:
                prop << item.voltage_setpoint_1
            EvalProp: Ch1A:
                prop << item.current_setpoint_1
            EvalProp: Ch2V:
                prop << item.voltage_setpoint_2
            EvalProp: Ch2A:
                prop << item.current_setpoint_2
            EvalProp: Ch3V:
                prop << item.voltage_setpoint_3
            EvalProp: Ch3A:
                prop << item.current_setpoint_3
        Label:
            text = ""
        Container:
            constraints = [
                vbox(
                    hbox(Ch1Va, Ch1Aa),
                    hbox(Ch2Va, Ch2Aa),
                    hbox(Ch3Va, Ch3Aa)
                )
            ]
            hug_width = 'strong'
            hug_height = 'strong'
            Label: Ch1Va:
                text := 'Channel 1 Voltage: {}'.format(item.actual_voltage_1)
            Label: Ch1Aa:
                text := 'Channel 1 Current: {}'.format(item.actual_current_1)
            Label: Ch2Va:
                text := 'Channel 2 Voltage: {}'.format(item.actual_voltage_2)
            Label: Ch2Aa:
                text := 'Channel 2 Current: {}'.format(item.actual_current_2)
            Label: Ch3Va:
                text := 'Channel 3 Voltage: {}'.format(item.actual_voltage_3)
            Label: Ch3Aa:
                text := 'Channel 3 Current: {}'.format(item.actual_current_3)
        PushButton: UpdateNow:
            text = 'Update Now'
            clicked :: item.update()

enamldef Instek_PSTs(Window):
    attr instek_psts

    title = 'Instek PST Power Supplies'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                    Label:
                        text = 'enable'
                    CheckBox:
                            checked := instek_psts.enable

                    IndexedContainer:
                        iterable << instek_psts.motors
                        viewType = Instek_PST


enamldef Vaunix(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text := 'Model: {}, Serial Number: {}, DLL ID: {}'.format(item.model,item.serial, item.ID)
        EvalProp: Frequency:
            prop << item.frequency
        EvalProp: Power:
            prop << item.power
        Form:
            hug_width = 'strong'
            hug_height = 'strong'
        Label:
            text = 'RF enabled'
        CheckBox: RFonoff:
            checked := item.rfonoff
        Form:
            hug_width = 'strong'
            hug_height = 'strong'
        Label:
            text = 'Use Internal Reference (External 10 MHz reference if Unchecked)'
        CheckBox: internalref:
            checked := item.internalref
        Container:
            Label:
                text = 'Pulse Modulation Mode'
            EvalProp: PulseWidth:
                prop << item.pulsewidth
            EvalProp: PulseRepRate:
                prop << item.pulserep
            Form:
                hug_width = 'strong'
                hug_height = 'strong'
                Label:
                    text = 'Enable Pulse Mode'
                CheckBox: PulseEnable:
                    checked := item.pulseenable
            Form:
                hug_width = 'strong'
                hug_height = 'strong'
                Label:
                    text = 'Use external modulation'
                CheckBox: ExternalMod:
                    checked := item.useexternalmod
        Container:
            Label:
                text = 'Frequency Sweep'
            EvalProp: StartFreq:
                prop << item.startfreq
            EvalProp: EndFreq:
                prop << item.endfreq
            EvalProp: SweepTime:
                prop << item.sweeptime
            Form:
                hug_width = 'strong'
                hug_height = 'strong'
                Label:
                    text = 'Enable Repetitive Sweep (Sweep Once if Unchecked)'
                CheckBox: SweepMode:
                    checked := item.sweepmode
            Form:
                hug_width = 'strong'
                hug_height = 'strong'
            Label:
                text = 'Sweep Positive (Negative if Unchecked)'
                CheckBox: SweepDir:
                    checked := item.sweepdir
            Form:
                hug_width = 'strong'
                hug_height = 'strong'
            Label:
                text = 'Enable Bidirectional Sweep (Unidirectional if Unchecked)'
                CheckBox: SweepType:
                    checked := item.sweeptype
            Form:
                hug_width = 'strong'
                hug_height = 'strong'
                Label:
                    text = 'ENABLE SWEEP'
                CheckBox: SweepEnable:
                    checked := item.sweepenable




enamldef Vaunixs(Window):
    attr vaunixs

    title = 'Vaunix signal generators'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                Label:
                    text = 'enable'
                    CheckBox:
                        checked := vaunixs.enable
                    PushButton: Detect:
                        text = 'Detect Signal Generators'
                        clicked :: vaunixs.detect_generators()
                IndexedContainer:
                    iterable << vaunixs.motors
                    viewType = Vaunix








enamldef AerotechGlobal(GroupBox):
    attr aglobal
    attr list_index

    HGroup: variable:
                    align_widths = False
    Label:
        text << list_index
    EvalProp:
        prop << aglobal



enamldef Aerotechs(Window):
    attr aerotechs

    title = 'Aerotech'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                    Label:
                        text = 'enable'
                    CheckBox:
                            checked := aerotechs.enable
                        #Label:
                        #    text = 'IP Address'
                        #Field:
                        #    text := aerotechs.IP
                        #Label:
                        #    text = 'port'
                        #IntField:
                        #    value := aerotechs.port
                        #PushButton:
                        #    text = 'Launch Server'
                        #    clicked :: aerotechs.launchServer()
                    PushButton:
                        text = 'Update Values'
                        clicked :: aerotechs.parUpdate()

                    #'''Container:
                    #    hug_width='strong'
                    #    hug_height='strong'
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.Xi
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.Xend
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.Xvmx
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.Xamx
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.Zi
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.Zend
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.Zvmx
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.Zamx
                    #    EvalProp:
                    #        prop << aerotechs.OneAerotech.XretTrig'''

                GroupBox:
                        HGroup:
                            SpinBox: spin0:
                                minimum=0
                                maximum << aerotechs.OneAerotech.globals.length
                            PushButton: addButton0:
                                text='+'
                                clicked::
                                    aerotechs.OneAerotech.globals.add_at(spin0.value)
                            PushButton: removeButton0:
                                text='-'
                                clicked::
                                    aerotechs.OneAerotech.globals.pop(spin0.value)

                RefreshableLooper:
                    iterable<<aerotechs.OneAerotech.globals
                    AerotechGlobal:
                        aglobal << loop_item
                        list_index << str(loop_index)

enamldef Aerotech(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        EvalProp:
            prop << item.Xi
        EvalProp:
            prop << item.Xend
        EvalProp:
            prop << item.Xvmx
        EvalProp:
            prop << item.Xamx
        EvalProp:
            prop << item.Zi
        EvalProp:
            prop << item.Zend
        EvalProp:
            prop << item.Zvmx
        EvalProp:
            prop << item.Zamx
        EvalProp:
            prop << item.XretTrig





enamldef Conexes(Window):
    attr conexes

    title = 'CONEX-CC'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                Form:
                    hug_width = 'strong'
                    hug_height = 'strong'
                Label:
                    text = 'enable'
                CheckBox:
                    checked := conexes.enable
                        #Label:
                        #    text = 'IP Address'
                        #Field:
                        #    text := conexes.IP
                        #Label:
                        #    text = 'port'
                        #IntField:
                        #    value := conexes.port
                        #PushButton:
                        #    text = 'Launch Server'
                        #    clicked :: conexes.launchServer()
                    PushButton:
                        text = 'Update Values'
                        clicked :: conexes.preIteration(0, 0)

                    IndexedContainer:
                        iterable << conexes.motors
                        viewType = Conex


enamldef Conex(Container):
    attr item
    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Form:
            Label:
                text = 'enable'
            CheckBox:
                checked := item.enable
        EvalProp:
            prop << item.IDString
        #Label:
        #    text = 'port'
        #IntField:
        #    value := item.port
        #PushButton:
        #    text = 'Launch Server'
        #    clicked :: item.launchServer()
        EvalProp:
            prop << item.SetPos
        Label:
            text = 'Velocity: '
        CheckBox:
            checked := item.enableVel
        EvalProp:
            prop << item.Vel
        EvalProp:
            prop << item.Threshold
        Label:
            text << "Most recent position: {} mm".format(item.curpos)







enamldef Picomotor(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text = 'serial number'
        Field:
            text := item.serial_number
        Label:
            text = 'motor number'
        Field:
            text := item.motor_number
        Label:
            text = 'position'
        EvalProp:
            prop << item.desired_position
        Label:
            text = str(item.current_position)
        Label:
            text = 'max error'
        Field:
            text := str(item.max_angle_error)



enamldef Picomotors(Window):
    attr picomotors

    title = 'Picomotors'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := picomotors.enable
                        Label:
                            text = 'IP Address'
                        Field:
                            text := picomotors.IP
                        Label:
                            text = 'port'
                        IntField:
                            value := picomotors.port

                    IndexedContainer:
                        iterable << picomotors.motors
                        viewType = Picomotor


enamldef Noise_Eater(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text = 'ip Address'
        Field:
            text := item.ip
        Label:
            text = 'ID'
        IntField:
            value := item.ID
        Label:
            text = 'Target Setting'
        EvalProp:
            prop << item.target_setting


enamldef Noise_Eaters(Window):
    attr noise_eaters
    attr analysis


    title = 'Noise Eaters'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := noise_eaters.enable

                    IndexedContainer:
                        iterable << noise_eaters.NEchannels
                        viewType = Noise_Eater



enamldef BILTcard(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text = 'chassis card number'
        Field:
            text := item.chassis_card_number
        Label:
            text = 'channel number'
        Field:
            text := item.channel_number
        Label:
            text = 'voltage'
        EvalProp:
            prop << item.desired_voltage

enamldef BILTcards(Window):
    attr BILT

    title = 'BILTcards'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := BILT.enable
                        Label:
                            text = 'IP Address'
                        Field:
                            text := BILT.IP
                        Label:
                            text = 'port'
                        IntField:
                            value := BILT.port

                    IndexedContainer:
                        iterable << BILT.channels
                        viewType = BILTcard

enamldef Fit_Sites(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text = 'Fit site'
        IntField:
            value := item.Fit_site
        Label:
            text = 'Fit Frequency x'
        EvalProp:
            prop << item.Fit_Frequency_x
        Label:
            text = 'Fit Frequency y'
        EvalProp:
            prop << item.Fit_Frequency_y
            
enamldef Force_Sites(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text = 'Force site'
        IntField:
            value := item.Force_site
        Label:
            text = 'Force Frequency x'
        EvalProp:
            prop << item.Force_Frequency_x
        Label:
            text = 'Force Frequency y'
        EvalProp:
            prop << item.Force_Frequency_y
            
enamldef Pattern_Sites(Container):
    attr item

    hug_width = 'strong'
    hug_height = 'strong'

    Container:
        hug_width = 'strong'
        hug_height = 'strong'
        Label:
            text = 'Site Occupation'
        IntField:
            value := item.occupation_site
        Label:
            text = 'Pattern Number'
        IntField:
            value := item.pattern_num

enamldef Rearrange(Window):
    attr rearrange

    title = 'Rearrange'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := rearrange.enable
                        Label:
                            text = 'IP Address'
                        Field:
                            text := rearrange.IP
                        Label:
                            text = 'port'
                        IntField:
                            value := rearrange.port

                    Container:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Form:
                            Label:
                                text = 'Jump Time'
                            EvalProp:
                                prop << rearrange.jump_time
                            Label:
                                text = 'frequency_increment'
                            EvalProp:
                                prop << rearrange.frequency_increment
                            Label:
                                text = 'laser_ramp_on_time'
                            EvalProp:
                                prop << rearrange.laser_ramp_on_time
                    Container:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Form:
                            Label:
                                text = 'sub array left'
                            IntField:
                                value := rearrange.sub_array_left
                            Label:
                                text = 'sub array top'
                            IntField:
                                value := rearrange.sub_array_top
                            Label:
                                text = 'sub array width'
                            IntField:
                                value := rearrange.sub_array_width 
                            Label:
                                text = 'sub array height'
                            IntField:
                                value := rearrange.sub_array_height   
                    IndexedContainer:
                        iterable << rearrange.fit_freq_sites
                        viewType = Fit_Sites
                    IndexedContainer:
                        iterable << rearrange.force_freq_sites
                        viewType = Force_Sites
                    IndexedContainer:
                        iterable << rearrange.site_pattern
                        viewType = Pattern_Sites

enamldef PyPico(Window):
    attr pypico

    title = 'PyPico Server'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'
            Form:
                hug_width = 'strong'
                hug_height = 'strong'
                Label:
                    text = 'enable'
                CheckBox:
                    checked := pypico.enable
                Label:
                    text = 'enable_measurement'
                CheckBox:
                    checked := pypico.enable_measurement
                Label:
                    text = 'enable_iteration'
                CheckBox:
                    checked := pypico.enable_iteration
                Label:
                    text = 'enable_movement'
                CheckBox:
                    checked := pypico.enable_movement
                Label:
                    text = 'IP Address'
                Field:
                    text := pypico.IP
                Label:
                    text = 'port'
                IntField:
                    value := pypico.port
                Label:
                    text = 'timeout (ms)'
                IntField:
                    value := pypico.timeout

            IndexedContainer:
                iterable << pypico.motors
                viewType = Picomotor

enamldef AAS(Window):
    attr aas

    title = 'Automatic Alignment System'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Container:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Form:
                        hug_width = 'strong'
                        hug_height = 'strong'
                        Label:
                            text = 'enable'
                        CheckBox:
                            checked := aas.enable
                        Label:
                            text = 'enable reordering shots'
                        CheckBox:
                            checked := aas.enable_reorder
                        Label:
                            text = 'enable feedback'
                        CheckBox:
                            checked := aas.enable_feedback
                        Label:
                            text = 'iter_analysis_path'
                        Field:
                            text := aas.iter_analysis_path
                        Label:
                            text = 'calibration X (pixels to degrees)'
                        FloatField:
                            value := aas.calibration_X
                        Label:
                            text = 'Setpoint X (pixels)'
                        FloatField:
                            value := aas.setpoint_X
                        Label:
                            text = 'Actuator X variable name'
                        Field:
                            text := aas.actuator_vname_X
                        Label:
                            text = 'calibration Y (pixels to degrees)'
                        FloatField:
                            value := aas.calibration_Y
                        Label:
                            text = 'Setpoint Y (pixels)'
                        FloatField:
                            value := aas.setpoint_Y
                        Label:
                            text = 'Actuator Y variable name'
                        Field:
                            text := aas.actuator_vname_Y
                        Label:
                            text = 'Relative Position (pixels)'
                        Label:
                            text = '(' + str(aas.position_iter_stat['x']) + ', ' + str(aas.position_iter_stat['y']) + ')'
                        Label:
                            text = 'Error (degrees)'
                        Label:
                            text = '(' + str(aas.position_iter_stat['error_x']) + ', ' + str(aas.position_iter_stat['error_y']) + ')'


enamldef Unlock_Pause(Window):
    attr unlock_pause

    title = 'Laser Unlock Monitor'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        Container:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                hug_width = 'strong'
                hug_height = 'strong'
                Form:
                    hug_width = 'strong'
                    hug_height = 'strong'
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := unlock_pause.enable

                    EvalProp:
                        prop << unlock_pause.IP
                    EvalProp:
                        prop << unlock_pause.Port
                    Label:
                        text := 'Unlocked brightness = {}'.format(unlock_pause.unlocked_brightness)
                    PushButton:
                        text = 'Update unlocked brightness'
                        clicked :: unlock_pause.get_brightness(0)
                    Label:
                        text := 'Locked brightness = {}'.format(unlock_pause.locked_brightness)
                    PushButton:
                        text = 'Update locked brightness'
                        clicked :: unlock_pause.get_brightness(1)
                    EvalProp:
                        prop << unlock_pause.Threshold


enamldef Filters(Window):
    attr experiment

    title = 'Filters'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                TTL_filters:
                    instrument = experiment.LabView.TTL
                    filters = experiment.TTL_filters
                LoadingFilters:
                    filters = experiment.error_filters
                LoadingFilters:
                    filters = experiment.loading_filters
                FirstMeasurementsFilter:
                    filters = experiment.first_measurements_filter

enamldef BoxTemperature(Window):
    attr box_temperature

    title = 'Box Temperature'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := box_temperature.enable
                    Label:
                        text = 'IP address'
                    Field:
                        text := box_temperature.IP
                    Label:
                        text = 'port'
                    IntField:
                        value := box_temperature.port
                    Label:
                        text = 'connected'
                    CheckBox:
                        checked << box_temperature.connected
                        enabled = False


enamldef PID(Window):
    attr experiment

    title = 'PID servo controller'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                pass

def loadIcon():
    #create icon
    with open(os.path.join('icons','2013_11_14_15_18_54_retention_PCA_filtered_image_rotated_smoothed.png'), 'rb') as f:
        data = f.read()
    image = Image(data=data)
    icon = Icon(images=[IconImage(image=image)])
    return icon

template ScrollPage(Title, Content):
    Page:
        alias content
        title = Title
        style_class << 'valid' if experiment.valid else 'invalid'
        Container:
            padding = 0
            style_class << 'valid' if experiment.valid else 'invalid'
            ScrollArea:
                style_class << 'valid' if experiment.valid else 'invalid'
                Content: content:
                    pass

template ScrollWindow(Title, Content):
    Window:
        alias content
        style_class << 'valid' if experiment.valid else 'invalid'
        Container:
            padding = 0
            style_class << 'valid' if experiment.valid else 'invalid'
            ScrollArea:
                style_class << 'valid' if experiment.valid else 'invalid'
                Content: content:
                    pass

enamldef RetentionAnalysis(Window):
    attr analysis

    title = 'Retention Analysis'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := analysis.enable
                    Label:
                        text << analysis.text

enamldef Origin(Window):
    attr origin

    title = 'Origin Interface'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'enable'
                    CheckBox:
                        checked := origin.enable
                    Label:
                        text = 'ip addr'
                    Label:
                        text := origin.IP
                    Label:
                        text = 'ports (register, data)'
                    Label:
                        text = str(origin.port_register)
                    Label:
                        text = 'stream namespace'
                    Field:
                        text := origin.streamNameSpace
                #EvalProp:
                #    prop << origin.timeout

                IndexedContainer:
                        iterable << origin.iterationDataList
                        viewType = Stream

                IndexedContainer:
                        iterable << origin.measurementDataList
                        viewType = Stream

enamldef Stream(Form):
    attr item

    constraints = [width >= 500, height >= 200]

    #title = 'Princeton Instruments Camera'
    style_class << 'valid' if experiment.valid else 'invalid'
    Container:
        padding = 0
        style_class << 'valid' if experiment.valid else 'invalid'
        ScrollArea:
            style_class << 'valid' if experiment.valid else 'invalid'
            Container:
                style_class << 'valid' if experiment.valid else 'invalid'

                Form:
                    Label:
                        text = 'data name'
                    Label:
                        text := item.name
                    Label:
                        text = 'full path'
                    Label:
                        text := item.fullPath
                    Label:
                        text = 'data type (numpy datatypes)'
                    Field:
                        text := item.dtype
                    Label:
                        text = 'stream name'
                    Field:
                        text := item.streamName
                    Label:
                        text = 'stream name on server'
                    Label:
                        text := item.streamNameFull
                    Label:
                        text = 'channels'
                    Label:
                        text := str(item.channels)
                    Label:
                        text = 'fields names on server'
                    Label:
                        text := str(item.fieldsList)
                    Label:
                        text = 'stream?'
                    CheckBox:
                        checked := item.stream


window_dictionary = {'':'',
                     'Experiment': 'ExperimentPage(experiment = main.experiment)',
                     'Independent Variables': 'IndependentVariables(independentVariables = main.experiment.independentVariables)',
                     'Constants and Dependent Vars': 'Variables(experiment = main.experiment)',
                     'Report': 'Reports(experiment = main.experiment)',
                     'PXI Communication': 'LabViewPage(LabView = main.experiment.LabView)',
                     'HSDIO': 'HSDIO_DigitalOutPage(HSDIO = main.experiment.LabView.HSDIO)',
                     'DAQmx': 'DAQmxDigitalOutPage(DAQmx = main.experiment.LabView.DAQmxDO)',
                     'DAQmxAI': 'DAQmxAI(NIDAQmxAI = main.experiment.DAQmxAI)',
                     'DDS': 'DDS_Page(DDS = main.experiment.DDS)',
                     'RF Generators': 'RFGenPage(LabView = main.experiment.LabView)',
                     'Hamamatsu': 'CameraPage(camera = main.experiment.LabView.camera)',
                     'Andor Cameras': 'Andors(andors = main.experiment.Andors)',
                     'Blackfly Client': 'BlackflyClient(blackfly_client = main.experiment.blackfly_client)',
                     'Princeton Instruments Camera': 'PICams(picams = main.experiment.PICams)',
                     'Vaunix Signal Generators': 'Vaunixs(vaunixs = main.experiment.vaunixs)',
                     'Newport Translation Stage': 'NewportStage(newportstage = main.experiment.NewportStage)',
                     'Analog Output': 'AnalogOutput(AO = main.experiment.LabView.AnalogOutput)',
                     'Analog Input': 'AnalogInput(AI = main.experiment.LabView.AnalogInput, filters = main.experiment.AI_filter, analysis = main.experiment.AI_graph)',
                     'Arroyo': 'Arroyo(experiment = main.experiment)',
                     'PI Piezo': 'PI_Piezo(piezo = main.experiment.LabView.piezo)',
                     'Picomotors': 'Picomotors(picomotors = main.experiment.picomotors)',
                     'Noise Eaters': 'Noise_Eaters(noise_eaters = main.experiment.noise_eaters)',
                     'Cell Electrodes': 'BILTcards(BILT = main.experiment.BILT)',
                     'Atom Rearranger': 'Rearrange(rearrange = main.experiment.rearrange)',
                     'PyPico': 'PyPico(pypico = main.experiment.pyPicoServer)',
                     'AAS': 'AAS(aas = main.experiment.beam_position_analysis)',
                     'AAS2': 'AAS(aas = main.experiment.beam_position_analysis2)',
                     'Instek PST Power Supplies': 'Instek_PSTs(instek_psts = main.experiment.instekpsts)',
                     'Aerotech': 'Aerotechs(aerotechs = main.experiment.aerotechs)',
                     'CONEX-CC': 'Conexes(conexes = main.experiment.conexes)',
                     'Live Images': 'MultiImage(experiment = main.experiment, analysis0 = main.experiment.recent_shot_analysis, analysis2 = main.experiment.imageSumAnalysis, analysis3 = main.experiment.text_analysis)',
                     'Image Browser': 'ImageBrowser(experiment = main.experiment, analysis1 = main.experiment.shotBrowserAnalysis)',
                     'Square ROI':  'SquareROIContainer(experiment = main.experiment, analysis = main.experiment.squareROIAnalysis)',
                     'Threshold ROI':  'ThresholdROIContainer(experiment = main.experiment, analysis = main.experiment.thresholdROIAnalysis)',
                     'Gaussian ROI': 'GaussianROI(analysis = main.experiment.gaussian_roi)',
                     'Histogram': 'Histogram(experiment = main.experiment, analysis = main.experiment.histogramAnalysis)',
                     'Histogram Grid': 'HistogramGrid(experiment = main.experiment, analysis = main.experiment.histogram_grid)',
                     'Measurements Graph': 'MeasurementsGraph(experiment = main.experiment, analysis = main.experiment.measurements_graph)',
                     'Iterations Graph': 'IterationsGraph(experiment = main.experiment, analysis = main.experiment.iterations_graph)',
                     'Retention Graph': 'RetentionGraph(experiment = main.experiment, analysis = main.experiment.retention_graph)',
                     'Filters': 'Filters(experiment = main.experiment)',
                     'Optimization': 'Optimizer(experiment = main.experiment, analysis = main.experiment.optimizer)',
                     'DC Noise Eaters': 'DCNoiseEaters(DC_noise_eaters = main.experiment.DC_noise_eaters, analysis = main.experiment.DC_noise_eater_graph, filters = main.experiment.DC_noise_eater_filter)',
                     'Box Temperature': 'BoxTemperature(box_temperature = main.experiment.box_temperature)',
                     'Ramsey': 'Ramsey(analysis = main.experiment.Ramsey)',
                     'PID': 'PID(experiment = main.experiment)',
                     'Retention Analysis': 'RetentionAnalysis(analysis = main.experiment.retention_analysis)',
                     'Counters': 'Counters(counters = main.experiment.LabView.Counters)',
                     'Functional Waveforms': 'FunctionalWaveforms(waveforms = main.experiment.functional_waveforms)',
                     'Functional Waveforms Graph': 'FunctionalWaveformsGraph(graph = main.experiment.functional_waveforms_graph)',
                     'CounterGraph': 'CounterGraph(analysis = main.experiment.counter_graph)',
                     'CounterHistAnalysis': 'CounterHistAnalysis(analysis = main.experiment.counter_hist)',
                     'Unlock Monitor': 'Unlock_Pause(unlock_pause = main.experiment.unlock_pause)',
                     'Origin Interface': 'Origin(origin = main.experiment.origin)',
                     'National Instruments Scopes': 'NIScopes(niscopes = main.experiment.NIScopes)'
                     }
window_keys = window_dictionary.keys()
window_keys.sort()


enamldef Main(MainWindow): main:
    attr experiment

    title='Saffmanlab experiment controller'
    #initial_position=(0,0)
    #initial_size=(1500,1100)
    icon = loadIcon()
    closing :: main.experiment.exiting()

    MyStyleSheet:
        #just implement the style sheet defined separately
        pass
    CsMenuBar:
        experiment=main.experiment
        mainWindow=main
    StatusBar:
        StatusItem:
            Label:
                text << 'Status: {}, Iteration: {}, Measurement: {}, Good Measurements: {}, Progress: {}%'.format(experiment.statusStr,experiment.iterationStr,experiment.measurementStr,experiment.goodMeasurementsStr,experiment.progressGUI)
        StatusItem:
            ProgressBar: progress:
                #constraints=[width==1200]
                minimum=0
                maximum=100
                value<<int(experiment.progressGUI)




    HGroup:
        align_widths = False
        Label: text = 'Select a window to open:'
        PushButton:
            text = 'open'
            clicked ::
                if combo.selected_item != '':
                    new = eval(window_dictionary[combo.selected_item])
                    new.show()
        ComboBox: combo:
            items = window_keys
            index ::
                if selected_item != '':
                    new = eval(window_dictionary[selected_item])
                    new.show()
